"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./components/exportWord.js":
/*!**********************************!*\
  !*** ./components/exportWord.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportToPdf: () => (/* binding */ exportToPdf)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/.pnpm/react@19.1.0/node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf */ \"(pages-dir-browser)/./node_modules/.pnpm/jspdf@3.0.1/node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jspdf-autotable */ \"(pages-dir-browser)/./node_modules/.pnpm/jspdf-autotable@5.0.2_jspdf@3.0.1/node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! marked */ \"(pages-dir-browser)/./node_modules/.pnpm/marked@15.0.12/node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var _barrel_optimize_names_CloudDownloadOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=CloudDownloadOutlined!=!@ant-design/icons */ \"(pages-dir-browser)/__barrel_optimize__?names=CloudDownloadOutlined!=!./node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@ant-design/icons/es/index.js\");\n// File: components/exportPdf.js\n\n\n// No importes 'jspdf-autotable' directamente para el side-effect aquí.\n// En su lugar, importaremos lo que necesitamos de él.\n // Importa la función autoTable\n\n\nconst DEFAULT_FONT_SIZE_PT = 10;\nconst TABLE_FONT_SIZE_PT = 6;\nconst HEADER_FONT_SIZE_PT = {\n    H1: 16,\n    H2: 14,\n    H3: 12,\n    H4: 10,\n    H5: 9,\n    H6: 8\n};\nconst LINE_HEIGHT_FACTOR = 1.2;\nconst MARGIN_PT = 30;\nfunction addText(doc, text, x, y, maxWidth) {\n    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};\n    // ... (mantener la función addText como antes)\n    const { fontSize = DEFAULT_FONT_SIZE_PT, fontStyle = 'normal', isHtml = false } = options;\n    doc.setFontSize(fontSize);\n    doc.setFont(undefined, fontStyle);\n    let processedText = text;\n    if (isHtml) {\n        processedText = text.replace(/<br\\s*\\/?>/gi, '\\n');\n        const tempDiv = document.createElement('div');\n        tempDiv.innerHTML = processedText;\n        processedText = tempDiv.textContent || tempDiv.innerText || \"\";\n    }\n    const lines = doc.splitTextToSize(processedText, maxWidth);\n    const textHeight = lines.length * fontSize * LINE_HEIGHT_FACTOR;\n    if (y + textHeight > doc.internal.pageSize.height - MARGIN_PT) {\n        doc.addPage();\n        y = MARGIN_PT;\n    }\n    doc.text(lines, x, y, {\n        lineHeightFactor: LINE_HEIGHT_FACTOR\n    });\n    return y + textHeight;\n}\nconst exportToPdf = async (markdownContent, programData, notification)=>{\n    if (!markdownContent) {\n        notification.warn({\n            message: 'Contenido Vacío',\n            description: 'No hay plan para exportar a PDF.'\n        });\n        return;\n    }\n    try {\n        var _programData_degree;\n        const htmlString = (0,marked__WEBPACK_IMPORTED_MODULE_3__.marked)(markdownContent);\n        const parser = new DOMParser();\n        const htmlDoc = parser.parseFromString(htmlString, 'text/html');\n        const bodyElements = Array.from(htmlDoc.body.children);\n        const doc = new jspdf__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n            orientation: 'p',\n            unit: 'pt',\n            format: 'a4'\n        });\n        // No es necesario llamar a applyPlugin(jsPDF) si importas autoTable como función\n        // Ahora llamarás a autoTable(doc, { ... }) en lugar de doc.autoTable({ ... })\n        let currentY = MARGIN_PT;\n        const contentWidth = doc.internal.pageSize.width - 2 * MARGIN_PT;\n        for (const element of bodyElements){\n            if (currentY > doc.internal.pageSize.height - MARGIN_PT - 20) {\n                doc.addPage();\n                currentY = MARGIN_PT;\n            }\n            const tagName = element.tagName.toUpperCase();\n            if (HEADER_FONT_SIZE_PT[tagName]) {\n                currentY = addText(doc, element.textContent, MARGIN_PT, currentY, contentWidth, {\n                    fontSize: HEADER_FONT_SIZE_PT[tagName],\n                    fontStyle: 'bold'\n                });\n                currentY += 5;\n            } else if (tagName === 'P') {\n                currentY = addText(doc, element.innerHTML, MARGIN_PT, currentY, contentWidth, {\n                    isHtml: true\n                });\n                currentY += 5;\n            } else if (tagName === 'UL' || tagName === 'OL') {\n                Array.from(element.children).forEach((li, idx)=>{\n                    if (currentY > doc.internal.pageSize.height - MARGIN_PT - 10) {\n                        doc.addPage();\n                        currentY = MARGIN_PT;\n                    }\n                    const prefix = tagName === 'UL' ? '• ' : \"\".concat(idx + 1, \". \");\n                    currentY = addText(doc, prefix + li.innerHTML, MARGIN_PT + 10, currentY, contentWidth - 10, {\n                        isHtml: true\n                    });\n                });\n                currentY += 5;\n            } else if (tagName === 'BLOCKQUOTE') {\n                doc.setFillColor(240, 240, 240);\n                const tempY = currentY;\n                const finalY = addText(doc, element.innerHTML, MARGIN_PT + 5, currentY, contentWidth - 10, {\n                    fontSize: DEFAULT_FONT_SIZE_PT - 1,\n                    fontStyle: 'italic',\n                    isHtml: true\n                });\n                doc.rect(MARGIN_PT, tempY - (DEFAULT_FONT_SIZE_PT - 1) / 2, 3, finalY - tempY + (DEFAULT_FONT_SIZE_PT - 1) / 2, 'F');\n                currentY = finalY + 5;\n            } else if (tagName === 'PRE' || tagName === 'CODE' && element.parentElement.tagName !== 'PRE') {\n                doc.setFont('courier', 'normal');\n                currentY = addText(doc, element.textContent, MARGIN_PT, currentY, contentWidth, {\n                    fontSize: DEFAULT_FONT_SIZE_PT - 2\n                });\n                doc.setFont(undefined, 'normal');\n                currentY += 5;\n            } else if (tagName === 'TABLE') {\n                const headRows = [];\n                element.querySelectorAll('thead tr').forEach((trNode)=>{\n                    const row = [];\n                    trNode.querySelectorAll('th').forEach((thNode)=>row.push(thNode.textContent.trim()));\n                    headRows.push(row);\n                });\n                const bodyRows = [];\n                element.querySelectorAll('tbody tr').forEach((trNode)=>{\n                    const row = [];\n                    trNode.querySelectorAll('td').forEach((tdNode)=>{\n                        const cellHTML = tdNode.innerHTML.replace(/<br\\s*\\/?>/gi, '\\n');\n                        const tempDiv = document.createElement('div');\n                        tempDiv.innerHTML = cellHTML;\n                        row.push(tempDiv.textContent || tempDiv.innerText || \"\");\n                    });\n                    bodyRows.push(row);\n                });\n                if (currentY + 20 > doc.internal.pageSize.height - MARGIN_PT) {\n                    doc.addPage();\n                    currentY = MARGIN_PT;\n                }\n                // CAMBIO AQUÍ: Llama a autoTable como una función, pasando 'doc'\n                (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(doc, {\n                    head: headRows,\n                    body: bodyRows,\n                    startY: currentY,\n                    theme: 'grid',\n                    styles: {\n                        fontSize: TABLE_FONT_SIZE_PT,\n                        cellPadding: 1.5,\n                        overflow: 'linebreak'\n                    },\n                    headStyles: {\n                        fillColor: [\n                            41,\n                            128,\n                            185\n                        ],\n                        textColor: [\n                            255,\n                            255,\n                            255\n                        ],\n                        fontStyle: 'bold',\n                        fontSize: TABLE_FONT_SIZE_PT + 1\n                    },\n                    margin: {\n                        left: MARGIN_PT,\n                        right: MARGIN_PT\n                    },\n                    tableWidth: 'auto'\n                });\n                currentY = doc.lastAutoTable.finalY + 10;\n            } else if (tagName === 'HR') {\n                if (currentY + 10 > doc.internal.pageSize.height - MARGIN_PT) {\n                    doc.addPage();\n                    currentY = MARGIN_PT;\n                }\n                doc.setDrawColor(180, 180, 180);\n                doc.line(MARGIN_PT, currentY, doc.internal.pageSize.width - MARGIN_PT, currentY);\n                currentY += 10;\n            } else if (element.textContent.trim()) {\n                console.warn(\"Elemento PDF no manejado explícitamente:\", tagName, element.textContent.substring(0, 30));\n                currentY = addText(doc, element.innerHTML, MARGIN_PT, currentY, contentWidth, {\n                    isHtml: true\n                });\n                currentY += 5;\n            }\n        }\n        const fileName = \"\".concat((programData === null || programData === void 0 ? void 0 : (_programData_degree = programData.degree) === null || _programData_degree === void 0 ? void 0 : _programData_degree.replace(/\\s+/g, '_')) || 'plan_curricular', \"_\").concat(new Date().toISOString().slice(0, 10), \".pdf\");\n        doc.save(fileName);\n        notification.success({\n            message: 'PDF Exportado',\n            description: \"El plan de estudios se ha guardado como \".concat(fileName, \".\"),\n            placement: 'bottomRight',\n            icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_CloudDownloadOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__.CloudDownloadOutlined, {\n                style: {\n                    color: '#52c41a'\n                }\n            }, void 0, false, {\n                fileName: \"/home/jordan/Documents/Software Directrices/CURRICULAFORGE/components/exportWord.js\",\n                lineNumber: 176,\n                columnNumber: 13\n            }, undefined)\n        });\n    } catch (error) {\n        console.error('Error al generar PDF:', error);\n        notification.error({\n            message: 'Error al Exportar PDF',\n            description: error.message || 'Ocurrió un problema al generar el archivo PDF.',\n            placement: 'bottomRight'\n        });\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvZXhwb3J0V29yZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsZ0NBQWdDOztBQUNOO0FBQzFCLHVFQUF1RTtBQUN2RSxzREFBc0Q7QUFDZCxDQUFDLCtCQUErQjtBQUN4QztBQUMwQjtBQUUxRCxNQUFNSSx1QkFBdUI7QUFDN0IsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLHNCQUFzQjtJQUFFQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBR0MsSUFBSTtBQUFFO0FBQzNFLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxZQUFZO0FBRWxCLFNBQVNDLFFBQVFDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsUUFBUTtRQUFFQyxVQUFBQSxpRUFBVSxDQUFDO0lBQ3JELCtDQUErQztJQUMvQyxNQUFNLEVBQ0pDLFdBQVdsQixvQkFBb0IsRUFDL0JtQixZQUFZLFFBQVEsRUFDcEJDLFNBQVMsS0FBSyxFQUNmLEdBQUdIO0lBRUpMLElBQUlTLFdBQVcsQ0FBQ0g7SUFDaEJOLElBQUlVLE9BQU8sQ0FBQ0MsV0FBV0o7SUFFdkIsSUFBSUssZ0JBQWdCWDtJQUNwQixJQUFJTyxRQUFRO1FBQ1ZJLGdCQUFnQlgsS0FBS1ksT0FBTyxDQUFDLGdCQUFnQjtRQUM3QyxNQUFNQyxVQUFVQyxTQUFTQyxhQUFhLENBQUM7UUFDdkNGLFFBQVFHLFNBQVMsR0FBR0w7UUFDcEJBLGdCQUFnQkUsUUFBUUksV0FBVyxJQUFJSixRQUFRSyxTQUFTLElBQUk7SUFDOUQ7SUFFQSxNQUFNQyxRQUFRcEIsSUFBSXFCLGVBQWUsQ0FBQ1QsZUFBZVI7SUFDakQsTUFBTWtCLGFBQWFGLE1BQU1HLE1BQU0sR0FBR2pCLFdBQVdUO0lBRTdDLElBQUlNLElBQUltQixhQUFhdEIsSUFBSXdCLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDQyxNQUFNLEdBQUc1QixXQUFXO1FBQzdERSxJQUFJMkIsT0FBTztRQUNYeEIsSUFBSUw7SUFDTjtJQUNBRSxJQUFJQyxJQUFJLENBQUNtQixPQUFPbEIsR0FBR0MsR0FBRztRQUFFeUIsa0JBQWtCL0I7SUFBbUI7SUFDN0QsT0FBT00sSUFBSW1CO0FBQ2I7QUFFTyxNQUFNTyxjQUFjLE9BQU9DLGlCQUFpQkMsYUFBYUM7SUFDOUQsSUFBSSxDQUFDRixpQkFBaUI7UUFDcEJFLGFBQWFDLElBQUksQ0FBQztZQUNoQkMsU0FBUztZQUNUQyxhQUFhO1FBQ2Y7UUFDQTtJQUNGO0lBRUEsSUFBSTtZQW1Ia0JKO1FBbEhwQixNQUFNSyxhQUFhbEQsOENBQU1BLENBQUM0QztRQUMxQixNQUFNTyxTQUFTLElBQUlDO1FBQ25CLE1BQU1DLFVBQVVGLE9BQU9HLGVBQWUsQ0FBQ0osWUFBWTtRQUNuRCxNQUFNSyxlQUFlQyxNQUFNQyxJQUFJLENBQUNKLFFBQVFLLElBQUksQ0FBQ0MsUUFBUTtRQUVyRCxNQUFNN0MsTUFBTSxJQUFJaEIsNkNBQUtBLENBQUM7WUFDcEI4RCxhQUFhO1lBQ2JDLE1BQU07WUFDTkMsUUFBUTtRQUNWO1FBRUEsaUZBQWlGO1FBQ2pGLDhFQUE4RTtRQUU5RSxJQUFJQyxXQUFXbkQ7UUFDZixNQUFNb0QsZUFBZWxELElBQUl3QixRQUFRLENBQUNDLFFBQVEsQ0FBQzBCLEtBQUssR0FBRyxJQUFJckQ7UUFFdkQsS0FBSyxNQUFNc0QsV0FBV1gsYUFBYztZQUNsQyxJQUFJUSxXQUFXakQsSUFBSXdCLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDQyxNQUFNLEdBQUc1QixZQUFZLElBQUk7Z0JBQzNERSxJQUFJMkIsT0FBTztnQkFDWHNCLFdBQVduRDtZQUNkO1lBRUEsTUFBTXVELFVBQVVELFFBQVFDLE9BQU8sQ0FBQ0MsV0FBVztZQUUzQyxJQUFJaEUsbUJBQW1CLENBQUMrRCxRQUFRLEVBQUU7Z0JBQ2hDSixXQUFXbEQsUUFBUUMsS0FBS29ELFFBQVFsQyxXQUFXLEVBQUVwQixXQUFXbUQsVUFBVUMsY0FBYztvQkFDOUU1QyxVQUFVaEIsbUJBQW1CLENBQUMrRCxRQUFRO29CQUN0QzlDLFdBQVc7Z0JBQ2I7Z0JBQ0EwQyxZQUFZO1lBQ2QsT0FBTyxJQUFJSSxZQUFZLEtBQUs7Z0JBQzFCSixXQUFXbEQsUUFBUUMsS0FBS29ELFFBQVFuQyxTQUFTLEVBQUVuQixXQUFXbUQsVUFBVUMsY0FBYztvQkFBRTFDLFFBQVE7Z0JBQUs7Z0JBQzdGeUMsWUFBWTtZQUNkLE9BQU8sSUFBSUksWUFBWSxRQUFRQSxZQUFZLE1BQU07Z0JBQy9DWCxNQUFNQyxJQUFJLENBQUNTLFFBQVFQLFFBQVEsRUFBRVUsT0FBTyxDQUFDLENBQUNDLElBQUlDO29CQUN4QyxJQUFJUixXQUFXakQsSUFBSXdCLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDQyxNQUFNLEdBQUc1QixZQUFZLElBQUk7d0JBQzVERSxJQUFJMkIsT0FBTzt3QkFBSXNCLFdBQVduRDtvQkFDNUI7b0JBQ0EsTUFBTTRELFNBQVNMLFlBQVksT0FBTyxPQUFPLEdBQVcsT0FBUkksTUFBTSxHQUFFO29CQUNwRFIsV0FBV2xELFFBQVFDLEtBQUswRCxTQUFTRixHQUFHdkMsU0FBUyxFQUFFbkIsWUFBWSxJQUFJbUQsVUFBVUMsZUFBZSxJQUFJO3dCQUFFMUMsUUFBUTtvQkFBSztnQkFDN0c7Z0JBQ0F5QyxZQUFZO1lBQ2QsT0FBTyxJQUFJSSxZQUFZLGNBQWM7Z0JBQ25DckQsSUFBSTJELFlBQVksQ0FBQyxLQUFLLEtBQUs7Z0JBQzNCLE1BQU1DLFFBQVFYO2dCQUNkLE1BQU1ZLFNBQVM5RCxRQUFRQyxLQUFLb0QsUUFBUW5DLFNBQVMsRUFBRW5CLFlBQVksR0FBR21ELFVBQVVDLGVBQWUsSUFBSTtvQkFBRTVDLFVBQVVsQix1QkFBc0I7b0JBQUdtQixXQUFXO29CQUFVQyxRQUFRO2dCQUFLO2dCQUNsS1IsSUFBSThELElBQUksQ0FBQ2hFLFdBQVc4RCxRQUFRLENBQUN4RSx1QkFBc0IsS0FBRyxHQUFJLEdBQUd5RSxTQUFTRCxRQUFRLENBQUN4RSx1QkFBc0IsS0FBRyxHQUFHO2dCQUMzRzZELFdBQVdZLFNBQVM7WUFDdEIsT0FBTyxJQUFJUixZQUFZLFNBQVVBLFlBQVksVUFBVUQsUUFBUVcsYUFBYSxDQUFDVixPQUFPLEtBQUssT0FBUTtnQkFDL0ZyRCxJQUFJVSxPQUFPLENBQUMsV0FBVztnQkFDdkJ1QyxXQUFXbEQsUUFBUUMsS0FBS29ELFFBQVFsQyxXQUFXLEVBQUVwQixXQUFXbUQsVUFBVUMsY0FBYztvQkFBRTVDLFVBQVVsQix1QkFBdUI7Z0JBQUU7Z0JBQ3JIWSxJQUFJVSxPQUFPLENBQUNDLFdBQVc7Z0JBQ3ZCc0MsWUFBWTtZQUNkLE9BQU8sSUFBSUksWUFBWSxTQUFTO2dCQUM5QixNQUFNVyxXQUFXLEVBQUU7Z0JBQ25CWixRQUFRYSxnQkFBZ0IsQ0FBQyxZQUFZVixPQUFPLENBQUNXLENBQUFBO29CQUN6QyxNQUFNQyxNQUFNLEVBQUU7b0JBQ2RELE9BQU9ELGdCQUFnQixDQUFDLE1BQU1WLE9BQU8sQ0FBQ2EsQ0FBQUEsU0FBVUQsSUFBSUUsSUFBSSxDQUFDRCxPQUFPbEQsV0FBVyxDQUFDb0QsSUFBSTtvQkFDaEZOLFNBQVNLLElBQUksQ0FBQ0Y7Z0JBQ2xCO2dCQUVBLE1BQU1JLFdBQVcsRUFBRTtnQkFDbkJuQixRQUFRYSxnQkFBZ0IsQ0FBQyxZQUFZVixPQUFPLENBQUNXLENBQUFBO29CQUN6QyxNQUFNQyxNQUFNLEVBQUU7b0JBQ2RELE9BQU9ELGdCQUFnQixDQUFDLE1BQU1WLE9BQU8sQ0FBQ2lCLENBQUFBO3dCQUNsQyxNQUFNQyxXQUFXRCxPQUFPdkQsU0FBUyxDQUFDSixPQUFPLENBQUMsZ0JBQWdCO3dCQUMxRCxNQUFNQyxVQUFVQyxTQUFTQyxhQUFhLENBQUM7d0JBQ3ZDRixRQUFRRyxTQUFTLEdBQUd3RDt3QkFDcEJOLElBQUlFLElBQUksQ0FBQ3ZELFFBQVFJLFdBQVcsSUFBSUosUUFBUUssU0FBUyxJQUFJO29CQUN6RDtvQkFDQW9ELFNBQVNGLElBQUksQ0FBQ0Y7Z0JBQ2xCO2dCQUVBLElBQUlsQixXQUFXLEtBQUtqRCxJQUFJd0IsUUFBUSxDQUFDQyxRQUFRLENBQUNDLE1BQU0sR0FBRzVCLFdBQVc7b0JBQzFERSxJQUFJMkIsT0FBTztvQkFDWHNCLFdBQVduRDtnQkFDZjtnQkFFQSxpRUFBaUU7Z0JBQ2pFYiwyREFBU0EsQ0FBQ2UsS0FBSztvQkFDYjBFLE1BQU1WO29CQUNOcEIsTUFBTTJCO29CQUNOSSxRQUFRMUI7b0JBQ1IyQixPQUFPO29CQUNQQyxRQUFRO3dCQUNOdkUsVUFBVWpCO3dCQUNWeUYsYUFBYTt3QkFDYkMsVUFBVTtvQkFDWjtvQkFDQUMsWUFBWTt3QkFDVkMsV0FBVzs0QkFBQzs0QkFBSTs0QkFBSzt5QkFBSTt3QkFDekJDLFdBQVc7NEJBQUM7NEJBQUs7NEJBQUs7eUJBQUk7d0JBQzFCM0UsV0FBVzt3QkFDWEQsVUFBVWpCLHFCQUFxQjtvQkFDakM7b0JBQ0E4RixRQUFRO3dCQUFFQyxNQUFNdEY7d0JBQVd1RixPQUFPdkY7b0JBQVU7b0JBQzVDd0YsWUFBWTtnQkFDZDtnQkFDQXJDLFdBQVdqRCxJQUFJdUYsYUFBYSxDQUFDMUIsTUFBTSxHQUFHO1lBQ3hDLE9BQU8sSUFBSVIsWUFBWSxNQUFNO2dCQUMzQixJQUFJSixXQUFXLEtBQUtqRCxJQUFJd0IsUUFBUSxDQUFDQyxRQUFRLENBQUNDLE1BQU0sR0FBRzVCLFdBQVc7b0JBQzFERSxJQUFJMkIsT0FBTztvQkFBSXNCLFdBQVduRDtnQkFDOUI7Z0JBQ0FFLElBQUl3RixZQUFZLENBQUMsS0FBSyxLQUFLO2dCQUMzQnhGLElBQUl5RixJQUFJLENBQUMzRixXQUFXbUQsVUFBVWpELElBQUl3QixRQUFRLENBQUNDLFFBQVEsQ0FBQzBCLEtBQUssR0FBR3JELFdBQVdtRDtnQkFDdkVBLFlBQVk7WUFDZCxPQUFPLElBQUlHLFFBQVFsQyxXQUFXLENBQUNvRCxJQUFJLElBQUk7Z0JBQ3JDb0IsUUFBUXpELElBQUksQ0FBQyw0Q0FBNENvQixTQUFTRCxRQUFRbEMsV0FBVyxDQUFDeUUsU0FBUyxDQUFDLEdBQUU7Z0JBQ2xHMUMsV0FBV2xELFFBQVFDLEtBQUtvRCxRQUFRbkMsU0FBUyxFQUFFbkIsV0FBV21ELFVBQVVDLGNBQWM7b0JBQUMxQyxRQUFRO2dCQUFJO2dCQUMzRnlDLFlBQVk7WUFDZDtRQUNGO1FBRUEsTUFBTTJDLFdBQVcsR0FBcUUsT0FBbEU3RCxDQUFBQSx3QkFBQUEsbUNBQUFBLHNCQUFBQSxZQUFhOEQsTUFBTSxjQUFuQjlELDBDQUFBQSxvQkFBcUJsQixPQUFPLENBQUMsUUFBUSxTQUFRLG1CQUFrQixLQUF5QyxPQUF0QyxJQUFJaUYsT0FBT0MsV0FBVyxHQUFHQyxLQUFLLENBQUMsR0FBRyxLQUFJO1FBQzVIaEcsSUFBSWlHLElBQUksQ0FBQ0w7UUFFVDVELGFBQWFrRSxPQUFPLENBQUM7WUFDbkJoRSxTQUFTO1lBQ1RDLGFBQWEsMkNBQW9ELE9BQVR5RCxVQUFTO1lBQ2pFTyxXQUFXO1lBQ1hDLG9CQUFNLDhEQUFDakgsZ0hBQXFCQTtnQkFBQ2tILE9BQU87b0JBQUVDLE9BQU87Z0JBQVU7Ozs7OztRQUN6RDtJQUVGLEVBQUUsT0FBT0MsT0FBTztRQUNkYixRQUFRYSxLQUFLLENBQUMseUJBQXlCQTtRQUN2Q3ZFLGFBQWF1RSxLQUFLLENBQUM7WUFDakJyRSxTQUFTO1lBQ1RDLGFBQWFvRSxNQUFNckUsT0FBTyxJQUFJO1lBQzlCaUUsV0FBVztRQUNiO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvaG9tZS9qb3JkYW4vRG9jdW1lbnRzL1NvZnR3YXJlIERpcmVjdHJpY2VzL0NVUlJJQ1VMQUZPUkdFL2NvbXBvbmVudHMvZXhwb3J0V29yZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlOiBjb21wb25lbnRzL2V4cG9ydFBkZi5qc1xuaW1wb3J0IGpzUERGIGZyb20gJ2pzcGRmJztcbi8vIE5vIGltcG9ydGVzICdqc3BkZi1hdXRvdGFibGUnIGRpcmVjdGFtZW50ZSBwYXJhIGVsIHNpZGUtZWZmZWN0IGFxdcOtLlxuLy8gRW4gc3UgbHVnYXIsIGltcG9ydGFyZW1vcyBsbyBxdWUgbmVjZXNpdGFtb3MgZGUgw6lsLlxuaW1wb3J0IGF1dG9UYWJsZSBmcm9tICdqc3BkZi1hdXRvdGFibGUnOyAvLyBJbXBvcnRhIGxhIGZ1bmNpw7NuIGF1dG9UYWJsZVxuaW1wb3J0IHsgbWFya2VkIH0gZnJvbSAnbWFya2VkJztcbmltcG9ydCB7IENsb3VkRG93bmxvYWRPdXRsaW5lZCB9IGZyb20gJ0BhbnQtZGVzaWduL2ljb25zJztcblxuY29uc3QgREVGQVVMVF9GT05UX1NJWkVfUFQgPSAxMDtcbmNvbnN0IFRBQkxFX0ZPTlRfU0laRV9QVCA9IDY7XG5jb25zdCBIRUFERVJfRk9OVF9TSVpFX1BUID0geyBIMTogMTYsIEgyOiAxNCwgSDM6IDEyLCBINDogMTAsIEg1OiA5LCBINjogOCB9O1xuY29uc3QgTElORV9IRUlHSFRfRkFDVE9SID0gMS4yO1xuY29uc3QgTUFSR0lOX1BUID0gMzA7XG5cbmZ1bmN0aW9uIGFkZFRleHQoZG9jLCB0ZXh0LCB4LCB5LCBtYXhXaWR0aCwgb3B0aW9ucyA9IHt9KSB7XG4gIC8vIC4uLiAobWFudGVuZXIgbGEgZnVuY2nDs24gYWRkVGV4dCBjb21vIGFudGVzKVxuICBjb25zdCB7XG4gICAgZm9udFNpemUgPSBERUZBVUxUX0ZPTlRfU0laRV9QVCxcbiAgICBmb250U3R5bGUgPSAnbm9ybWFsJyxcbiAgICBpc0h0bWwgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcblxuICBkb2Muc2V0Rm9udFNpemUoZm9udFNpemUpO1xuICBkb2Muc2V0Rm9udCh1bmRlZmluZWQsIGZvbnRTdHlsZSk7XG5cbiAgbGV0IHByb2Nlc3NlZFRleHQgPSB0ZXh0O1xuICBpZiAoaXNIdG1sKSB7XG4gICAgcHJvY2Vzc2VkVGV4dCA9IHRleHQucmVwbGFjZSgvPGJyXFxzKlxcLz8+L2dpLCAnXFxuJyk7XG4gICAgY29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gcHJvY2Vzc2VkVGV4dDtcbiAgICBwcm9jZXNzZWRUZXh0ID0gdGVtcERpdi50ZXh0Q29udGVudCB8fCB0ZW1wRGl2LmlubmVyVGV4dCB8fCBcIlwiO1xuICB9XG5cbiAgY29uc3QgbGluZXMgPSBkb2Muc3BsaXRUZXh0VG9TaXplKHByb2Nlc3NlZFRleHQsIG1heFdpZHRoKTtcbiAgY29uc3QgdGV4dEhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGZvbnRTaXplICogTElORV9IRUlHSFRfRkFDVE9SO1xuXG4gIGlmICh5ICsgdGV4dEhlaWdodCA+IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQgLSBNQVJHSU5fUFQpIHtcbiAgICBkb2MuYWRkUGFnZSgpO1xuICAgIHkgPSBNQVJHSU5fUFQ7XG4gIH1cbiAgZG9jLnRleHQobGluZXMsIHgsIHksIHsgbGluZUhlaWdodEZhY3RvcjogTElORV9IRUlHSFRfRkFDVE9SIH0pO1xuICByZXR1cm4geSArIHRleHRIZWlnaHQ7XG59XG5cbmV4cG9ydCBjb25zdCBleHBvcnRUb1BkZiA9IGFzeW5jIChtYXJrZG93bkNvbnRlbnQsIHByb2dyYW1EYXRhLCBub3RpZmljYXRpb24pID0+IHtcbiAgaWYgKCFtYXJrZG93bkNvbnRlbnQpIHtcbiAgICBub3RpZmljYXRpb24ud2Fybih7XG4gICAgICBtZXNzYWdlOiAnQ29udGVuaWRvIFZhY8OtbycsXG4gICAgICBkZXNjcmlwdGlvbjogJ05vIGhheSBwbGFuIHBhcmEgZXhwb3J0YXIgYSBQREYuJyxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGh0bWxTdHJpbmcgPSBtYXJrZWQobWFya2Rvd25Db250ZW50KTtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgY29uc3QgaHRtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaHRtbFN0cmluZywgJ3RleHQvaHRtbCcpO1xuICAgIGNvbnN0IGJvZHlFbGVtZW50cyA9IEFycmF5LmZyb20oaHRtbERvYy5ib2R5LmNoaWxkcmVuKTtcblxuICAgIGNvbnN0IGRvYyA9IG5ldyBqc1BERih7XG4gICAgICBvcmllbnRhdGlvbjogJ3AnLFxuICAgICAgdW5pdDogJ3B0JyxcbiAgICAgIGZvcm1hdDogJ2E0JyxcbiAgICB9KTtcblxuICAgIC8vIE5vIGVzIG5lY2VzYXJpbyBsbGFtYXIgYSBhcHBseVBsdWdpbihqc1BERikgc2kgaW1wb3J0YXMgYXV0b1RhYmxlIGNvbW8gZnVuY2nDs25cbiAgICAvLyBBaG9yYSBsbGFtYXLDoXMgYSBhdXRvVGFibGUoZG9jLCB7IC4uLiB9KSBlbiBsdWdhciBkZSBkb2MuYXV0b1RhYmxlKHsgLi4uIH0pXG5cbiAgICBsZXQgY3VycmVudFkgPSBNQVJHSU5fUFQ7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gZG9jLmludGVybmFsLnBhZ2VTaXplLndpZHRoIC0gMiAqIE1BUkdJTl9QVDtcblxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBib2R5RWxlbWVudHMpIHtcbiAgICAgIGlmIChjdXJyZW50WSA+IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQgLSBNQVJHSU5fUFQgLSAyMCkge1xuICAgICAgICAgZG9jLmFkZFBhZ2UoKTtcbiAgICAgICAgIGN1cnJlbnRZID0gTUFSR0lOX1BUO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgIGlmIChIRUFERVJfRk9OVF9TSVpFX1BUW3RhZ05hbWVdKSB7XG4gICAgICAgIGN1cnJlbnRZID0gYWRkVGV4dChkb2MsIGVsZW1lbnQudGV4dENvbnRlbnQsIE1BUkdJTl9QVCwgY3VycmVudFksIGNvbnRlbnRXaWR0aCwge1xuICAgICAgICAgIGZvbnRTaXplOiBIRUFERVJfRk9OVF9TSVpFX1BUW3RhZ05hbWVdLFxuICAgICAgICAgIGZvbnRTdHlsZTogJ2JvbGQnLFxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudFkgKz0gNTtcbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ1AnKSB7XG4gICAgICAgIGN1cnJlbnRZID0gYWRkVGV4dChkb2MsIGVsZW1lbnQuaW5uZXJIVE1MLCBNQVJHSU5fUFQsIGN1cnJlbnRZLCBjb250ZW50V2lkdGgsIHsgaXNIdG1sOiB0cnVlIH0pO1xuICAgICAgICBjdXJyZW50WSArPSA1O1xuICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnVUwnIHx8IHRhZ05hbWUgPT09ICdPTCcpIHtcbiAgICAgICAgQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkcmVuKS5mb3JFYWNoKChsaSwgaWR4KSA9PiB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRZID4gZG9jLmludGVybmFsLnBhZ2VTaXplLmhlaWdodCAtIE1BUkdJTl9QVCAtIDEwKSB7XG4gICAgICAgICAgICBkb2MuYWRkUGFnZSgpOyBjdXJyZW50WSA9IE1BUkdJTl9QVDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHJlZml4ID0gdGFnTmFtZSA9PT0gJ1VMJyA/ICfigKIgJyA6IGAke2lkeCArIDF9LiBgO1xuICAgICAgICAgIGN1cnJlbnRZID0gYWRkVGV4dChkb2MsIHByZWZpeCArIGxpLmlubmVySFRNTCwgTUFSR0lOX1BUICsgMTAsIGN1cnJlbnRZLCBjb250ZW50V2lkdGggLSAxMCwgeyBpc0h0bWw6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50WSArPSA1O1xuICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnQkxPQ0tRVU9URScpIHtcbiAgICAgICAgZG9jLnNldEZpbGxDb2xvcigyNDAsIDI0MCwgMjQwKTtcbiAgICAgICAgY29uc3QgdGVtcFkgPSBjdXJyZW50WTtcbiAgICAgICAgY29uc3QgZmluYWxZID0gYWRkVGV4dChkb2MsIGVsZW1lbnQuaW5uZXJIVE1MLCBNQVJHSU5fUFQgKyA1LCBjdXJyZW50WSwgY29udGVudFdpZHRoIC0gMTAsIHsgZm9udFNpemU6IERFRkFVTFRfRk9OVF9TSVpFX1BUIC0xLCBmb250U3R5bGU6ICdpdGFsaWMnLCBpc0h0bWw6IHRydWUgfSk7XG4gICAgICAgIGRvYy5yZWN0KE1BUkdJTl9QVCwgdGVtcFkgLSAoREVGQVVMVF9GT05UX1NJWkVfUFQgLTEpLzIgLCAzLCBmaW5hbFkgLSB0ZW1wWSArIChERUZBVUxUX0ZPTlRfU0laRV9QVCAtMSkvMiwgJ0YnKTtcbiAgICAgICAgY3VycmVudFkgPSBmaW5hbFkgKyA1O1xuICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnUFJFJyB8fCAodGFnTmFtZSA9PT0gJ0NPREUnICYmIGVsZW1lbnQucGFyZW50RWxlbWVudC50YWdOYW1lICE9PSAnUFJFJykpIHtcbiAgICAgICAgZG9jLnNldEZvbnQoJ2NvdXJpZXInLCAnbm9ybWFsJyk7XG4gICAgICAgIGN1cnJlbnRZID0gYWRkVGV4dChkb2MsIGVsZW1lbnQudGV4dENvbnRlbnQsIE1BUkdJTl9QVCwgY3VycmVudFksIGNvbnRlbnRXaWR0aCwgeyBmb250U2l6ZTogREVGQVVMVF9GT05UX1NJWkVfUFQgLSAyIH0pO1xuICAgICAgICBkb2Muc2V0Rm9udCh1bmRlZmluZWQsICdub3JtYWwnKTtcbiAgICAgICAgY3VycmVudFkgKz0gNTtcbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICBjb25zdCBoZWFkUm93cyA9IFtdO1xuICAgICAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RoZWFkIHRyJykuZm9yRWFjaCh0ck5vZGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gW107XG4gICAgICAgICAgICB0ck5vZGUucXVlcnlTZWxlY3RvckFsbCgndGgnKS5mb3JFYWNoKHRoTm9kZSA9PiByb3cucHVzaCh0aE5vZGUudGV4dENvbnRlbnQudHJpbSgpKSk7XG4gICAgICAgICAgICBoZWFkUm93cy5wdXNoKHJvdyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGJvZHlSb3dzID0gW107XG4gICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgndGJvZHkgdHInKS5mb3JFYWNoKHRyTm9kZSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgICAgIHRyTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZCcpLmZvckVhY2godGROb2RlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsSFRNTCA9IHRkTm9kZS5pbm5lckhUTUwucmVwbGFjZSgvPGJyXFxzKlxcLz8+L2dpLCAnXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gY2VsbEhUTUw7XG4gICAgICAgICAgICAgICAgcm93LnB1c2godGVtcERpdi50ZXh0Q29udGVudCB8fCB0ZW1wRGl2LmlubmVyVGV4dCB8fCBcIlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYm9keVJvd3MucHVzaChyb3cpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjdXJyZW50WSArIDIwID4gZG9jLmludGVybmFsLnBhZ2VTaXplLmhlaWdodCAtIE1BUkdJTl9QVCkge1xuICAgICAgICAgICAgZG9jLmFkZFBhZ2UoKTtcbiAgICAgICAgICAgIGN1cnJlbnRZID0gTUFSR0lOX1BUO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ0FNQklPIEFRVcONOiBMbGFtYSBhIGF1dG9UYWJsZSBjb21vIHVuYSBmdW5jacOzbiwgcGFzYW5kbyAnZG9jJ1xuICAgICAgICBhdXRvVGFibGUoZG9jLCB7IC8vIDwtLS0gQ0FNQklPIElNUE9SVEFOVEVcbiAgICAgICAgICBoZWFkOiBoZWFkUm93cyxcbiAgICAgICAgICBib2R5OiBib2R5Um93cyxcbiAgICAgICAgICBzdGFydFk6IGN1cnJlbnRZLFxuICAgICAgICAgIHRoZW1lOiAnZ3JpZCcsXG4gICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogVEFCTEVfRk9OVF9TSVpFX1BULFxuICAgICAgICAgICAgY2VsbFBhZGRpbmc6IDEuNSxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnbGluZWJyZWFrJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRTdHlsZXM6IHtcbiAgICAgICAgICAgIGZpbGxDb2xvcjogWzQxLCAxMjgsIDE4NV0sXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IFsyNTUsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIGZvbnRTdHlsZTogJ2JvbGQnLFxuICAgICAgICAgICAgZm9udFNpemU6IFRBQkxFX0ZPTlRfU0laRV9QVCArIDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXJnaW46IHsgbGVmdDogTUFSR0lOX1BULCByaWdodDogTUFSR0lOX1BUIH0sXG4gICAgICAgICAgdGFibGVXaWR0aDogJ2F1dG8nLFxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudFkgPSBkb2MubGFzdEF1dG9UYWJsZS5maW5hbFkgKyAxMDtcbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ0hSJykge1xuICAgICAgICBpZiAoY3VycmVudFkgKyAxMCA+IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQgLSBNQVJHSU5fUFQpIHtcbiAgICAgICAgICAgIGRvYy5hZGRQYWdlKCk7IGN1cnJlbnRZID0gTUFSR0lOX1BUO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5zZXREcmF3Q29sb3IoMTgwLCAxODAsIDE4MCk7XG4gICAgICAgIGRvYy5saW5lKE1BUkdJTl9QVCwgY3VycmVudFksIGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS53aWR0aCAtIE1BUkdJTl9QVCwgY3VycmVudFkpO1xuICAgICAgICBjdXJyZW50WSArPSAxMDtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC50ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRWxlbWVudG8gUERGIG5vIG1hbmVqYWRvIGV4cGzDrWNpdGFtZW50ZTpcIiwgdGFnTmFtZSwgZWxlbWVudC50ZXh0Q29udGVudC5zdWJzdHJpbmcoMCwzMCkpO1xuICAgICAgICBjdXJyZW50WSA9IGFkZFRleHQoZG9jLCBlbGVtZW50LmlubmVySFRNTCwgTUFSR0lOX1BULCBjdXJyZW50WSwgY29udGVudFdpZHRoLCB7aXNIdG1sOiB0cnVlfSk7XG4gICAgICAgIGN1cnJlbnRZICs9IDU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZU5hbWUgPSBgJHtwcm9ncmFtRGF0YT8uZGVncmVlPy5yZXBsYWNlKC9cXHMrL2csICdfJykgfHwgJ3BsYW5fY3VycmljdWxhcid9XyR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDEwKX0ucGRmYDtcbiAgICBkb2Muc2F2ZShmaWxlTmFtZSk7XG5cbiAgICBub3RpZmljYXRpb24uc3VjY2Vzcyh7XG4gICAgICBtZXNzYWdlOiAnUERGIEV4cG9ydGFkbycsXG4gICAgICBkZXNjcmlwdGlvbjogYEVsIHBsYW4gZGUgZXN0dWRpb3Mgc2UgaGEgZ3VhcmRhZG8gY29tbyAke2ZpbGVOYW1lfS5gLFxuICAgICAgcGxhY2VtZW50OiAnYm90dG9tUmlnaHQnLFxuICAgICAgaWNvbjogPENsb3VkRG93bmxvYWRPdXRsaW5lZCBzdHlsZT17eyBjb2xvcjogJyM1MmM0MWEnIH19IC8+LFxuICAgIH0pO1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgZ2VuZXJhciBQREY6JywgZXJyb3IpO1xuICAgIG5vdGlmaWNhdGlvbi5lcnJvcih7XG4gICAgICBtZXNzYWdlOiAnRXJyb3IgYWwgRXhwb3J0YXIgUERGJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBlcnJvci5tZXNzYWdlIHx8ICdPY3VycmnDsyB1biBwcm9ibGVtYSBhbCBnZW5lcmFyIGVsIGFyY2hpdm8gUERGLicsXG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b21SaWdodCcsXG4gICAgfSk7XG4gIH1cbn07Il0sIm5hbWVzIjpbImpzUERGIiwiYXV0b1RhYmxlIiwibWFya2VkIiwiQ2xvdWREb3dubG9hZE91dGxpbmVkIiwiREVGQVVMVF9GT05UX1NJWkVfUFQiLCJUQUJMRV9GT05UX1NJWkVfUFQiLCJIRUFERVJfRk9OVF9TSVpFX1BUIiwiSDEiLCJIMiIsIkgzIiwiSDQiLCJINSIsIkg2IiwiTElORV9IRUlHSFRfRkFDVE9SIiwiTUFSR0lOX1BUIiwiYWRkVGV4dCIsImRvYyIsInRleHQiLCJ4IiwieSIsIm1heFdpZHRoIiwib3B0aW9ucyIsImZvbnRTaXplIiwiZm9udFN0eWxlIiwiaXNIdG1sIiwic2V0Rm9udFNpemUiLCJzZXRGb250IiwidW5kZWZpbmVkIiwicHJvY2Vzc2VkVGV4dCIsInJlcGxhY2UiLCJ0ZW1wRGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwidGV4dENvbnRlbnQiLCJpbm5lclRleHQiLCJsaW5lcyIsInNwbGl0VGV4dFRvU2l6ZSIsInRleHRIZWlnaHQiLCJsZW5ndGgiLCJpbnRlcm5hbCIsInBhZ2VTaXplIiwiaGVpZ2h0IiwiYWRkUGFnZSIsImxpbmVIZWlnaHRGYWN0b3IiLCJleHBvcnRUb1BkZiIsIm1hcmtkb3duQ29udGVudCIsInByb2dyYW1EYXRhIiwibm90aWZpY2F0aW9uIiwid2FybiIsIm1lc3NhZ2UiLCJkZXNjcmlwdGlvbiIsImh0bWxTdHJpbmciLCJwYXJzZXIiLCJET01QYXJzZXIiLCJodG1sRG9jIiwicGFyc2VGcm9tU3RyaW5nIiwiYm9keUVsZW1lbnRzIiwiQXJyYXkiLCJmcm9tIiwiYm9keSIsImNoaWxkcmVuIiwib3JpZW50YXRpb24iLCJ1bml0IiwiZm9ybWF0IiwiY3VycmVudFkiLCJjb250ZW50V2lkdGgiLCJ3aWR0aCIsImVsZW1lbnQiLCJ0YWdOYW1lIiwidG9VcHBlckNhc2UiLCJmb3JFYWNoIiwibGkiLCJpZHgiLCJwcmVmaXgiLCJzZXRGaWxsQ29sb3IiLCJ0ZW1wWSIsImZpbmFsWSIsInJlY3QiLCJwYXJlbnRFbGVtZW50IiwiaGVhZFJvd3MiLCJxdWVyeVNlbGVjdG9yQWxsIiwidHJOb2RlIiwicm93IiwidGhOb2RlIiwicHVzaCIsInRyaW0iLCJib2R5Um93cyIsInRkTm9kZSIsImNlbGxIVE1MIiwiaGVhZCIsInN0YXJ0WSIsInRoZW1lIiwic3R5bGVzIiwiY2VsbFBhZGRpbmciLCJvdmVyZmxvdyIsImhlYWRTdHlsZXMiLCJmaWxsQ29sb3IiLCJ0ZXh0Q29sb3IiLCJtYXJnaW4iLCJsZWZ0IiwicmlnaHQiLCJ0YWJsZVdpZHRoIiwibGFzdEF1dG9UYWJsZSIsInNldERyYXdDb2xvciIsImxpbmUiLCJjb25zb2xlIiwic3Vic3RyaW5nIiwiZmlsZU5hbWUiLCJkZWdyZWUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzbGljZSIsInNhdmUiLCJzdWNjZXNzIiwicGxhY2VtZW50IiwiaWNvbiIsInN0eWxlIiwiY29sb3IiLCJlcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/exportWord.js\n"));

/***/ })

});