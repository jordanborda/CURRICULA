"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./components/exportWord.js":
/*!**********************************!*\
  !*** ./components/exportWord.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportToWord: () => (/* binding */ exportToWord)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/.pnpm/react@19.1.0/node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var docx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! docx */ \"(pages-dir-browser)/./node_modules/.pnpm/docx@9.5.0/node_modules/docx/dist/index.mjs\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! file-saver */ \"(pages-dir-browser)/./node_modules/.pnpm/file-saver@2.0.5/node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! marked */ \"(pages-dir-browser)/./node_modules/.pnpm/marked@15.0.12/node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var _barrel_optimize_names_CloudDownloadOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=CloudDownloadOutlined!=!@ant-design/icons */ \"(pages-dir-browser)/__barrel_optimize__?names=CloudDownloadOutlined!=!./node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@ant-design/icons/es/index.js\");\n// File: components/exportWord.js\n\n\n\n\n\n// --- Funciones Helper para construir el documento DOCX ---\nfunction parseHtmlForDocxRuns(htmlString) {\n    const runs = [];\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = htmlString.trim(); // Trim para evitar nodos de texto vacíos al inicio/final\n    function processNode(currentNode) {\n        let currentOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (currentNode.nodeType === Node.TEXT_NODE) {\n            if (currentNode.textContent.trim() !== \"\" || runs.length === 0 || runs[runs.length - 1] && runs[runs.length - 1].break) {\n                runs.push(new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                    text: currentNode.textContent,\n                    ...currentOptions\n                }));\n            }\n        } else if (currentNode.nodeType === Node.ELEMENT_NODE) {\n            const tagName = currentNode.tagName.toLowerCase();\n            let newOptions = {\n                ...currentOptions\n            }; // Heredar opciones\n            if (tagName === 'strong' || tagName === 'b') {\n                newOptions.bold = true;\n            } else if (tagName === 'em' || tagName === 'i') {\n                newOptions.italics = true;\n            } else if (tagName === 'u') {\n                newOptions.underline = {}; // Opciones de subrayado más detalladas disponibles\n            } else if (tagName === 'code') {\n                newOptions.font = {\n                    name: \"Courier New\"\n                };\n            // Podrías añadir un estilo de sombreado o borde aquí si 'docx' lo permite para TextRun\n            } else if (tagName === 'br') {\n                runs.push(new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                    break: 1,\n                    ...newOptions\n                })); // Mantener opciones para el break si aplica\n                // No procesar hijos de <br>\n                return;\n            }\n            // Para otras etiquetas inline, podrías añadir más conversiones (ej. span con estilos)\n            Array.from(currentNode.childNodes).forEach((child)=>processNode(child, newOptions));\n        }\n    }\n    Array.from(tempDiv.childNodes).forEach((child)=>processNode(child));\n    return runs;\n}\nfunction createParagraphFromHtmlNode(htmlNode) {\n    let numberingConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    const runs = parseHtmlForDocxRuns(htmlNode.innerHTML);\n    const paragraphOptions = {\n        children: runs.length > 0 ? runs : [\n            new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun(\"\")\n        ]\n    };\n    if (numberingConfig) {\n        paragraphOptions.numbering = {\n            reference: numberingConfig.reference,\n            level: level\n        };\n    }\n    // Aquí podrías añadir lógica para alineación basada en clases CSS si fuera necesario.\n    return new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph(paragraphOptions);\n}\nfunction createTableFromHtmlTable(htmlTableNode) {\n    const rows = [];\n    let columnCount = 0;\n    // Encabezados (thead)\n    htmlTableNode.querySelectorAll('thead tr').forEach((trNode)=>{\n        const cells = [];\n        let currentColumnCountInRow = 0;\n        trNode.querySelectorAll('th').forEach((thNode)=>{\n            cells.push(new docx__WEBPACK_IMPORTED_MODULE_1__.TableCell({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        children: parseHtmlForDocxRuns(thNode.innerHTML),\n                        alignment: docx__WEBPACK_IMPORTED_MODULE_1__.AlignmentType.CENTER\n                    })\n                ],\n                shading: {\n                    fill: \"D9D9D9\",\n                    type: docx__WEBPACK_IMPORTED_MODULE_1__.ShadingType.CLEAR,\n                    color: \"auto\"\n                },\n                verticalAlign: docx__WEBPACK_IMPORTED_MODULE_1__.VerticalAlign.CENTER\n            }));\n            currentColumnCountInRow++;\n        });\n        if (currentColumnCountInRow > columnCount) columnCount = currentColumnCountInRow;\n        if (cells.length > 0) rows.push(new docx__WEBPACK_IMPORTED_MODULE_1__.TableRow({\n            children: cells,\n            tableHeader: true\n        }));\n    });\n    // Cuerpo (tbody)\n    htmlTableNode.querySelectorAll('tbody tr').forEach((trNode)=>{\n        const cells = [];\n        let currentColumnCountInRow = 0;\n        trNode.querySelectorAll('td').forEach((tdNode)=>{\n            const cellParagraphs = [];\n            // Manejar <br> dentro de celdas dividiendo por <br> y creando múltiples párrafos\n            const cellHtmlParts = tdNode.innerHTML.split(/<br\\s*\\/?>/gi);\n            cellHtmlParts.forEach((part)=>{\n                if (part.trim() !== \"\" || cellParagraphs.length === 0) {\n                    cellParagraphs.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        children: parseHtmlForDocxRuns(part)\n                    }));\n                }\n            });\n            cells.push(new docx__WEBPACK_IMPORTED_MODULE_1__.TableCell({\n                children: cellParagraphs.length > 0 ? cellParagraphs : [\n                    new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph(\"\")\n                ],\n                verticalAlign: docx__WEBPACK_IMPORTED_MODULE_1__.VerticalAlign.TOP\n            }));\n            currentColumnCountInRow++;\n        });\n        if (currentColumnCountInRow > columnCount) columnCount = currentColumnCountInRow;\n        if (cells.length > 0) rows.push(new docx__WEBPACK_IMPORTED_MODULE_1__.TableRow({\n            children: cells\n        }));\n    });\n    if (rows.length === 0) return null;\n    // Definir anchos de columna (ejemplo: distribuir equitativamente)\n    // Esto es muy básico. Para anchos más precisos, necesitarías leer atributos 'width' del HTML\n    // o tener una heurística más avanzada.\n    const columnWidths = columnCount > 0 ? Array(columnCount).fill(100 / columnCount) : [];\n    return new docx__WEBPACK_IMPORTED_MODULE_1__.Table({\n        rows: rows,\n        width: {\n            size: 100,\n            type: docx__WEBPACK_IMPORTED_MODULE_1__.WidthType.PERCENTAGE\n        },\n        // Si tienes columnWidths en porcentaje:\n        columnWidths: columnWidths.map((w)=>100 / columnCount * (9024 / 100)),\n        // O un ancho fijo por columna:\n        // columnWidths: Array(columnCount).fill(convertInchesToTwip(6 / columnCount)),\n        borders: {\n            top: {\n                style: docx__WEBPACK_IMPORTED_MODULE_1__.BorderStyle.SINGLE,\n                size: 1,\n                color: \"000000\"\n            },\n            bottom: {\n                style: docx__WEBPACK_IMPORTED_MODULE_1__.BorderStyle.SINGLE,\n                size: 1,\n                color: \"000000\"\n            },\n            left: {\n                style: docx__WEBPACK_IMPORTED_MODULE_1__.BorderStyle.SINGLE,\n                size: 1,\n                color: \"000000\"\n            },\n            right: {\n                style: docx__WEBPACK_IMPORTED_MODULE_1__.BorderStyle.SINGLE,\n                size: 1,\n                color: \"000000\"\n            },\n            insideHorizontal: {\n                style: docx__WEBPACK_IMPORTED_MODULE_1__.BorderStyle.SINGLE,\n                size: 1,\n                color: \"000000\"\n            },\n            insideVertical: {\n                style: docx__WEBPACK_IMPORTED_MODULE_1__.BorderStyle.SINGLE,\n                size: 1,\n                color: \"000000\"\n            }\n        }\n    });\n}\n// --- Función Principal de Exportación ---\nconst exportToWord = async (markdownContent, programData, notification)=>{\n    console.log('[WORD DOCXJS EXPORT] Iniciando exportación...');\n    if (!markdownContent || markdownContent.trim() === \"\") {\n        notification.warn({\n            message: 'Contenido Vacío',\n            description: 'No hay plan para exportar a Word.'\n        });\n        return;\n    }\n    console.log('[WORD DOCXJS EXPORT] Contenido Markdown (100 chars):', markdownContent.substring(0, 100));\n    try {\n        const htmlString = (0,marked__WEBPACK_IMPORTED_MODULE_3__.marked)(markdownContent, {\n            breaks: true\n        }); // breaks: true para que <br> se maneje mejor\n        console.log('[WORD DOCXJS EXPORT] HTML generado (200 chars):', htmlString.substring(0, 200));\n        const parser = new DOMParser();\n        const htmlDoc = parser.parseFromString(htmlString, 'text/html');\n        const bodyElements = Array.from(htmlDoc.body.children);\n        console.log(\"[WORD DOCXJS EXPORT] \".concat(bodyElements.length, \" elementos principales en HTML body.\"));\n        const docChildren = [];\n        const abstractNumbering = new docx__WEBPACK_IMPORTED_MODULE_1__.AbstractNumbering({\n            levels: [\n                {\n                    level: 0,\n                    format: \"bullet\",\n                    text: \"\\u2022\",\n                    style: {\n                        paragraph: {\n                            indent: {\n                                left: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.25),\n                                hanging: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.25)\n                            }\n                        }\n                    }\n                },\n                {\n                    level: 1,\n                    format: \"bullet\",\n                    text: \"\\u25E6\",\n                    style: {\n                        paragraph: {\n                            indent: {\n                                left: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.5),\n                                hanging: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.25)\n                            }\n                        }\n                    }\n                }\n            ]\n        });\n        const abstractDecimalNumbering = new docx__WEBPACK_IMPORTED_MODULE_1__.AbstractNumbering({\n            levels: [\n                {\n                    level: 0,\n                    format: \"decimal\",\n                    text: \"%1.\",\n                    style: {\n                        paragraph: {\n                            indent: {\n                                left: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.25),\n                                hanging: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.25)\n                            }\n                        }\n                    },\n                    suffix: docx__WEBPACK_IMPORTED_MODULE_1__.LevelSuffix.TAB\n                },\n                {\n                    level: 1,\n                    format: \"lowerLetter\",\n                    text: \"%2)\",\n                    style: {\n                        paragraph: {\n                            indent: {\n                                left: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.5),\n                                hanging: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.25)\n                            }\n                        }\n                    },\n                    suffix: docx__WEBPACK_IMPORTED_MODULE_1__.LevelSuffix.TAB\n                }\n            ]\n        });\n        const listNumbering = new docx__WEBPACK_IMPORTED_MODULE_1__.Numbering({\n            config: [\n                {\n                    reference: \"bullet-numbering\",\n                    abstractNumbering: abstractNumbering\n                },\n                {\n                    reference: \"decimal-numbering\",\n                    abstractNumbering: abstractDecimalNumbering\n                }\n            ]\n        });\n        bodyElements.forEach((element)=>{\n            const tagName = element.tagName.toLowerCase();\n            console.log(\"[WORD DOCXJS EXPORT] Procesando elemento: \".concat(tagName));\n            switch(tagName){\n                case 'h1':\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        children: parseHtmlForDocxRuns(element.innerHTML),\n                        heading: docx__WEBPACK_IMPORTED_MODULE_1__.HeadingLevel.HEADING_1\n                    }));\n                    break;\n                case 'h2':\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        children: parseHtmlForDocxRuns(element.innerHTML),\n                        heading: docx__WEBPACK_IMPORTED_MODULE_1__.HeadingLevel.HEADING_2\n                    }));\n                    break;\n                case 'h3':\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        children: parseHtmlForDocxRuns(element.innerHTML),\n                        heading: docx__WEBPACK_IMPORTED_MODULE_1__.HeadingLevel.HEADING_3\n                    }));\n                    break;\n                case 'h4':\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        children: parseHtmlForDocxRuns(element.innerHTML),\n                        heading: docx__WEBPACK_IMPORTED_MODULE_1__.HeadingLevel.HEADING_4\n                    }));\n                    break;\n                case 'h5':\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        children: parseHtmlForDocxRuns(element.innerHTML),\n                        heading: docx__WEBPACK_IMPORTED_MODULE_1__.HeadingLevel.HEADING_5\n                    }));\n                    break;\n                case 'h6':\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        children: parseHtmlForDocxRuns(element.innerHTML),\n                        heading: docx__WEBPACK_IMPORTED_MODULE_1__.HeadingLevel.HEADING_6\n                    }));\n                    break;\n                case 'p':\n                    docChildren.push(createParagraphFromHtmlNode(element));\n                    break;\n                case 'ul':\n                    Array.from(element.children).forEach((li)=>{\n                        if (li.tagName.toLowerCase() === 'li') {\n                            docChildren.push(createParagraphFromHtmlNode(li, {\n                                reference: \"bullet-numbering\"\n                            }, 0)); // Nivel 0 para UL simple\n                        }\n                    });\n                    break;\n                case 'ol':\n                    Array.from(element.children).forEach((li)=>{\n                        if (li.tagName.toLowerCase() === 'li') {\n                            docChildren.push(createParagraphFromHtmlNode(li, {\n                                reference: \"decimal-numbering\"\n                            }, 0)); // Nivel 0 para OL simple\n                        }\n                    });\n                    break;\n                case 'table':\n                    const docxTable = createTableFromHtmlTable(element);\n                    if (docxTable) docChildren.push(docxTable);\n                    else console.warn(\"[WORD DOCXJS EXPORT] Se omitió una tabla vacía o malformada.\");\n                    break;\n                case 'blockquote':\n                    const bqPara = createParagraphFromHtmlNode(element);\n                    bqPara.options.indent = {\n                        left: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.5)\n                    };\n                    // Podrías definir un estilo para blockquotes con bordes, etc.\n                    docChildren.push(bqPara);\n                    break;\n                case 'pre':\n                    const codeText = element.querySelector('code') ? element.querySelector('code').textContent : element.textContent;\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        children: [\n                            new docx__WEBPACK_IMPORTED_MODULE_1__.TextRun({\n                                text: codeText || \"\",\n                                font: {\n                                    name: \"Courier New\",\n                                    size: \"9pt\"\n                                }\n                            })\n                        ],\n                        shading: {\n                            fill: \"F1F1F1\",\n                            type: docx__WEBPACK_IMPORTED_MODULE_1__.ShadingType.CLEAR,\n                            color: \"auto\"\n                        }\n                    }));\n                    break;\n                case 'hr':\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph({\n                        // Simulación de HR con un borde inferior de párrafo\n                        border: {\n                            bottom: {\n                                style: docx__WEBPACK_IMPORTED_MODULE_1__.BorderStyle.SINGLE,\n                                size: 6,\n                                color: \"BFBFBF\"\n                            }\n                        }\n                    }));\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph(\"\")); // Espacio después del HR\n                    break;\n                default:\n                    console.warn(\"[WORD DOCXJS EXPORT] Etiqueta no manejada: \".concat(tagName, \". Intentando como p\\xe1rrafo.\"));\n                    if (element.textContent && element.textContent.trim() !== \"\") {\n                        docChildren.push(createParagraphFromHtmlNode(element));\n                    }\n            }\n        });\n        if (docChildren.length === 0) {\n            console.warn(\"[WORD DOCXJS EXPORT] No se generaron elementos para el documento Word.\");\n            docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_1__.Paragraph(\"El contenido no pudo ser procesado para Word.\"));\n        }\n        console.log(\"[WORD DOCXJS EXPORT] Creando Document object con docx...\");\n        const doc = new docx__WEBPACK_IMPORTED_MODULE_1__.Document({\n            numbering: listNumbering,\n            sections: [\n                {\n                    properties: {\n                        page: {\n                            margin: {\n                                top: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.75),\n                                right: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.75),\n                                bottom: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.75),\n                                left: (0,docx__WEBPACK_IMPORTED_MODULE_1__.convertInchesToTwip)(0.75)\n                            }\n                        }\n                    },\n                    children: docChildren\n                }\n            ]\n        });\n        console.log(\"[WORD DOCXJS EXPORT] Empaquetando documento con Packer...\");\n        docx__WEBPACK_IMPORTED_MODULE_1__.Packer.toBlob(doc).then((blob)=>{\n            var _programData_degree;\n            console.log(\"[WORD DOCXJS EXPORT] Blob DOCX generado, tama\\xf1o: \".concat(blob.size, \" bytes\"));\n            if (blob.size < 500) {\n                // Este umbral es arbitrario, ajusta si es necesario.\n                console.warn(\"[WORD DOCXJS EXPORT] El blob generado es muy pequeño, podría estar casi vacío o corrupto.\");\n            // Podrías no descargar si es muy pequeño o mostrar una advertencia adicional.\n            }\n            const fileName = \"\".concat((programData === null || programData === void 0 ? void 0 : (_programData_degree = programData.degree) === null || _programData_degree === void 0 ? void 0 : _programData_degree.replace(/\\s+/g, '_')) || 'plan_curricular', \"_\").concat(new Date().toISOString().slice(0, 10), \".docx\");\n            (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(blob, fileName);\n            console.log(\"[WORD DOCXJS EXPORT] saveAs llamado.\");\n            notification.success({\n                message: 'Word Exportado (docx)',\n                description: \"El plan deber\\xeda estar descarg\\xe1ndose como \".concat(fileName, \".\"),\n                placement: 'bottomRight',\n                icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_CloudDownloadOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__.CloudDownloadOutlined, {\n                    style: {\n                        color: '#52c41a'\n                    }\n                }, void 0, false, {\n                    fileName: \"/home/jordan/Documents/Software Directrices/CURRICULAFORGE/components/exportWord.js\",\n                    lineNumber: 286,\n                    columnNumber: 23\n                }, undefined)\n            });\n        }).catch((packError)=>{\n            console.error('[WORD DOCXJS EXPORT] Error en Packer.toBlob:', packError);\n            notification.error({\n                message: 'Error Empaquetando Word',\n                description: packError.message || 'Fallo al empaquetar el DOCX.'\n            });\n        });\n    } catch (error) {\n        console.error('[WORD DOCXJS EXPORT] Error GENERAL:', error);\n        notification.error({\n            message: 'Error al Exportar Word',\n            description: error.message || 'Problema al generar archivo DOCX.'\n        });\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvZXhwb3J0V29yZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLGlDQUFpQzs7QUFLbkI7QUFDc0I7QUFDSjtBQUMwQjtBQUcxRCw0REFBNEQ7QUFFNUQsU0FBU3NCLHFCQUFxQkMsVUFBVTtJQUNwQyxNQUFNQyxPQUFPLEVBQUU7SUFDZixNQUFNQyxVQUFVQyxTQUFTQyxhQUFhLENBQUM7SUFDdkNGLFFBQVFHLFNBQVMsR0FBR0wsV0FBV00sSUFBSSxJQUFJLHlEQUF5RDtJQUVoRyxTQUFTQyxZQUFZQyxXQUFXO1lBQUVDLGlCQUFBQSxpRUFBaUIsQ0FBQztRQUNoRCxJQUFJRCxZQUFZRSxRQUFRLEtBQUtDLEtBQUtDLFNBQVMsRUFBRTtZQUN6QyxJQUFJSixZQUFZSyxXQUFXLENBQUNQLElBQUksT0FBTyxNQUFNTCxLQUFLYSxNQUFNLEtBQUssS0FBTWIsSUFBSSxDQUFDQSxLQUFLYSxNQUFNLEdBQUUsRUFBRSxJQUFJYixJQUFJLENBQUNBLEtBQUthLE1BQU0sR0FBQyxFQUFFLENBQUNDLEtBQUssRUFBRztnQkFDbEhkLEtBQUtlLElBQUksQ0FBQyxJQUFJcEMseUNBQU9BLENBQUM7b0JBQUVxQyxNQUFNVCxZQUFZSyxXQUFXO29CQUFFLEdBQUdKLGNBQWM7Z0JBQUM7WUFDOUU7UUFDSixPQUFPLElBQUlELFlBQVlFLFFBQVEsS0FBS0MsS0FBS08sWUFBWSxFQUFFO1lBQ25ELE1BQU1DLFVBQVVYLFlBQVlXLE9BQU8sQ0FBQ0MsV0FBVztZQUMvQyxJQUFJQyxhQUFhO2dCQUFFLEdBQUdaLGNBQWM7WUFBQyxHQUFHLG1CQUFtQjtZQUUzRCxJQUFJVSxZQUFZLFlBQVlBLFlBQVksS0FBSztnQkFDekNFLFdBQVdDLElBQUksR0FBRztZQUN0QixPQUFPLElBQUlILFlBQVksUUFBUUEsWUFBWSxLQUFLO2dCQUM1Q0UsV0FBV0UsT0FBTyxHQUFHO1lBQ3pCLE9BQU8sSUFBSUosWUFBWSxLQUFLO2dC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YTRELEtBQUssQ0FBQztnQkFBRXhELFNBQVM7Z0JBQTJCQyxhQUFhc0QsVUFBVXZELE9BQU8sSUFBSTtZQUErQjtRQUM5SDtJQUVKLEVBQUUsT0FBT3dELE9BQU87UUFDWjNELFFBQVEyRCxLQUFLLENBQUMsdUNBQXVDQTtRQUNyRDVELGFBQWE0RCxLQUFLLENBQUM7WUFBRXhELFNBQVM7WUFBMEJDLGFBQWF1RCxNQUFNeEQsT0FBTyxJQUFJO1FBQW9DO0lBQzlIO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsiL2hvbWUvam9yZGFuL0RvY3VtZW50cy9Tb2Z0d2FyZSBEaXJlY3RyaWNlcy9DVVJSSUNVTEFGT1JHRS9jb21wb25lbnRzL2V4cG9ydFdvcmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZTogY29tcG9uZW50cy9leHBvcnRXb3JkLmpzXG5pbXBvcnQge1xuICAgIERvY3VtZW50LCBQYWNrZXIsIFBhcmFncmFwaCwgVGV4dFJ1biwgSGVhZGluZ0xldmVsLCBUYWJsZSwgVGFibGVSb3csIFRhYmxlQ2VsbCxcbiAgICBXaWR0aFR5cGUsIEJvcmRlclN0eWxlLCBBbGlnbm1lbnRUeXBlLCBjb252ZXJ0SW5jaGVzVG9Ud2lwLCBTaGFkaW5nVHlwZSwgVmVydGljYWxBbGlnbixcbiAgICBOdW1iZXJpbmcsIEluZGVudCwgTGV2ZWxTdWZmaXgsIFN0eWxlTGV2ZWwsIEFic3RyYWN0TnVtYmVyaW5nXG59IGZyb20gJ2RvY3gnO1xuaW1wb3J0IHsgc2F2ZUFzIH0gZnJvbSAnZmlsZS1zYXZlcic7XG5pbXBvcnQgeyBtYXJrZWQgfSBmcm9tICdtYXJrZWQnO1xuaW1wb3J0IHsgQ2xvdWREb3dubG9hZE91dGxpbmVkIH0gZnJvbSAnQGFudC1kZXNpZ24vaWNvbnMnO1xuXG5cbi8vIC0tLSBGdW5jaW9uZXMgSGVscGVyIHBhcmEgY29uc3RydWlyIGVsIGRvY3VtZW50byBET0NYIC0tLVxuXG5mdW5jdGlvbiBwYXJzZUh0bWxGb3JEb2N4UnVucyhodG1sU3RyaW5nKSB7XG4gICAgY29uc3QgcnVucyA9IFtdO1xuICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0ZW1wRGl2LmlubmVySFRNTCA9IGh0bWxTdHJpbmcudHJpbSgpOyAvLyBUcmltIHBhcmEgZXZpdGFyIG5vZG9zIGRlIHRleHRvIHZhY8Otb3MgYWwgaW5pY2lvL2ZpbmFsXG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShjdXJyZW50Tm9kZSwgY3VycmVudE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUudGV4dENvbnRlbnQudHJpbSgpICE9PSBcIlwiIHx8IHJ1bnMubGVuZ3RoID09PSAwIHx8IChydW5zW3J1bnMubGVuZ3RoIC0xXSAmJiBydW5zW3J1bnMubGVuZ3RoLTFdLmJyZWFrKSkgeyAvLyBFdml0YXIgVGV4dFJ1bnMgdmFjw61vcyBhIG1lbm9zIHF1ZSBzZWEgZWwgcHJpbWVybyBvIGRlc3B1w6lzIGRlIHVuIGJyZWFrXG4gICAgICAgICAgICAgICAgIHJ1bnMucHVzaChuZXcgVGV4dFJ1bih7IHRleHQ6IGN1cnJlbnROb2RlLnRleHRDb250ZW50LCAuLi5jdXJyZW50T3B0aW9ucyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gY3VycmVudE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgbGV0IG5ld09wdGlvbnMgPSB7IC4uLmN1cnJlbnRPcHRpb25zIH07IC8vIEhlcmVkYXIgb3BjaW9uZXNcblxuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdzdHJvbmcnIHx8IHRhZ05hbWUgPT09ICdiJykge1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbnMuYm9sZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdlbScgfHwgdGFnTmFtZSA9PT0gJ2knKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9ucy5pdGFsaWNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9ucy51bmRlcmxpbmUgPSB7fTsgLy8gT3BjaW9uZXMgZGUgc3VicmF5YWRvIG3DoXMgZGV0YWxsYWRhcyBkaXNwb25pYmxlc1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnY29kZScpIHtcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25zLmZvbnQgPSB7IG5hbWU6IFwiQ291cmllciBOZXdcIiB9O1xuICAgICAgICAgICAgICAgIC8vIFBvZHLDrWFzIGHDsWFkaXIgdW4gZXN0aWxvIGRlIHNvbWJyZWFkbyBvIGJvcmRlIGFxdcOtIHNpICdkb2N4JyBsbyBwZXJtaXRlIHBhcmEgVGV4dFJ1blxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnYnInKSB7XG4gICAgICAgICAgICAgICAgcnVucy5wdXNoKG5ldyBUZXh0UnVuKHsgYnJlYWs6IDEsIC4uLm5ld09wdGlvbnMgfSkpOyAvLyBNYW50ZW5lciBvcGNpb25lcyBwYXJhIGVsIGJyZWFrIHNpIGFwbGljYVxuICAgICAgICAgICAgICAgIC8vIE5vIHByb2Nlc2FyIGhpam9zIGRlIDxicj5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJhIG90cmFzIGV0aXF1ZXRhcyBpbmxpbmUsIHBvZHLDrWFzIGHDsWFkaXIgbcOhcyBjb252ZXJzaW9uZXMgKGVqLiBzcGFuIGNvbiBlc3RpbG9zKVxuXG4gICAgICAgICAgICBBcnJheS5mcm9tKGN1cnJlbnROb2RlLmNoaWxkTm9kZXMpLmZvckVhY2goY2hpbGQgPT4gcHJvY2Vzc05vZGUoY2hpbGQsIG5ld09wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEFycmF5LmZyb20odGVtcERpdi5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHByb2Nlc3NOb2RlKGNoaWxkKSk7XG4gICAgcmV0dXJuIHJ1bnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFncmFwaEZyb21IdG1sTm9kZShodG1sTm9kZSwgbnVtYmVyaW5nQ29uZmlnID0gbnVsbCwgbGV2ZWwgPSAwKSB7XG4gICAgY29uc3QgcnVucyA9IHBhcnNlSHRtbEZvckRvY3hSdW5zKGh0bWxOb2RlLmlubmVySFRNTCk7XG4gICAgY29uc3QgcGFyYWdyYXBoT3B0aW9ucyA9IHtcbiAgICAgICAgY2hpbGRyZW46IHJ1bnMubGVuZ3RoID4gMCA/IHJ1bnMgOiBbbmV3IFRleHRSdW4oXCJcIildLCAvLyBFdml0YXIgZXJyb3Igc2kgbm8gaGF5IHJ1bnNcbiAgICB9O1xuXG4gICAgaWYgKG51bWJlcmluZ0NvbmZpZykge1xuICAgICAgICBwYXJhZ3JhcGhPcHRpb25zLm51bWJlcmluZyA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZTogbnVtYmVyaW5nQ29uZmlnLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXF1w60gcG9kcsOtYXMgYcOxYWRpciBsw7NnaWNhIHBhcmEgYWxpbmVhY2nDs24gYmFzYWRhIGVuIGNsYXNlcyBDU1Mgc2kgZnVlcmEgbmVjZXNhcmlvLlxuICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHBhcmFncmFwaE9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUYWJsZUZyb21IdG1sVGFibGUoaHRtbFRhYmxlTm9kZSkge1xuICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAwO1xuXG4gICAgLy8gRW5jYWJlemFkb3MgKHRoZWFkKVxuICAgIGh0bWxUYWJsZU5vZGUucXVlcnlTZWxlY3RvckFsbCgndGhlYWQgdHInKS5mb3JFYWNoKHRyTm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50Q29sdW1uQ291bnRJblJvdyA9IDA7XG4gICAgICAgIHRyTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0aCcpLmZvckVhY2godGhOb2RlID0+IHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IFRhYmxlQ2VsbCh7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbbmV3IFBhcmFncmFwaCh7IC8vIExvcyBlbmNhYmV6YWRvcyBzdWVsZW4gc2VyIHVuYSBzb2xhIGzDrW5lYVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHBhcnNlSHRtbEZvckRvY3hSdW5zKHRoTm9kZS5pbm5lckhUTUwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiBBbGlnbm1lbnRUeXBlLkNFTlRFUixcbiAgICAgICAgICAgICAgICAgICAgfSldLFxuICAgICAgICAgICAgICAgICAgICBzaGFkaW5nOiB7IGZpbGw6IFwiRDlEOUQ5XCIsIHR5cGU6IFNoYWRpbmdUeXBlLkNMRUFSLCBjb2xvcjogXCJhdXRvXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogVmVydGljYWxBbGlnbi5DRU5URVIsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uQ291bnRJblJvdysrO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN1cnJlbnRDb2x1bW5Db3VudEluUm93ID4gY29sdW1uQ291bnQpIGNvbHVtbkNvdW50ID0gY3VycmVudENvbHVtbkNvdW50SW5Sb3c7XG4gICAgICAgIGlmIChjZWxscy5sZW5ndGggPiAwKSByb3dzLnB1c2gobmV3IFRhYmxlUm93KHsgY2hpbGRyZW46IGNlbGxzLCB0YWJsZUhlYWRlcjogdHJ1ZSB9KSk7XG4gICAgfSk7XG5cbiAgICAvLyBDdWVycG8gKHRib2R5KVxuICAgIGh0bWxUYWJsZU5vZGUucXVlcnlTZWxlY3RvckFsbCgndGJvZHkgdHInKS5mb3JFYWNoKHRyTm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50Q29sdW1uQ291bnRJblJvdyA9IDA7XG4gICAgICAgIHRyTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZCcpLmZvckVhY2godGROb2RlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxQYXJhZ3JhcGhzID0gW107XG4gICAgICAgICAgICAvLyBNYW5lamFyIDxicj4gZGVudHJvIGRlIGNlbGRhcyBkaXZpZGllbmRvIHBvciA8YnI+IHkgY3JlYW5kbyBtw7psdGlwbGVzIHDDoXJyYWZvc1xuICAgICAgICAgICAgY29uc3QgY2VsbEh0bWxQYXJ0cyA9IHRkTm9kZS5pbm5lckhUTUwuc3BsaXQoLzxiclxccypcXC8/Pi9naSk7XG4gICAgICAgICAgICBjZWxsSHRtbFBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQudHJpbSgpICE9PSBcIlwiIHx8IGNlbGxQYXJhZ3JhcGhzLmxlbmd0aCA9PT0gMCkgeyAvLyBBw7FhZGlyIGluY2x1c28gc2kgZXMgdW4gcMOhcnJhZm8gdmFjw61vIGRlc3B1w6lzIGRlIHVuIDxicj5cbiAgICAgICAgICAgICAgICAgICAgY2VsbFBhcmFncmFwaHMucHVzaChuZXcgUGFyYWdyYXBoKHsgY2hpbGRyZW46IHBhcnNlSHRtbEZvckRvY3hSdW5zKHBhcnQpIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2VsbHMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgVGFibGVDZWxsKHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGNlbGxQYXJhZ3JhcGhzLmxlbmd0aCA+IDAgPyBjZWxsUGFyYWdyYXBocyA6IFtuZXcgUGFyYWdyYXBoKFwiXCIpXSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogVmVydGljYWxBbGlnbi5UT1AsIC8vIE8gQ0VOVEVSIHNlZ8O6biBwcmVmZXJlbmNpYVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudENvbHVtbkNvdW50SW5Sb3crKztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdXJyZW50Q29sdW1uQ291bnRJblJvdyA+IGNvbHVtbkNvdW50KSBjb2x1bW5Db3VudCA9IGN1cnJlbnRDb2x1bW5Db3VudEluUm93O1xuICAgICAgICBpZiAoY2VsbHMubGVuZ3RoID4gMCkgcm93cy5wdXNoKG5ldyBUYWJsZVJvdyh7IGNoaWxkcmVuOiBjZWxscyB9KSk7XG4gICAgfSk7XG5cbiAgICBpZiAocm93cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgLy8gRGVmaW5pciBhbmNob3MgZGUgY29sdW1uYSAoZWplbXBsbzogZGlzdHJpYnVpciBlcXVpdGF0aXZhbWVudGUpXG4gICAgLy8gRXN0byBlcyBtdXkgYsOhc2ljby4gUGFyYSBhbmNob3MgbcOhcyBwcmVjaXNvcywgbmVjZXNpdGFyw61hcyBsZWVyIGF0cmlidXRvcyAnd2lkdGgnIGRlbCBIVE1MXG4gICAgLy8gbyB0ZW5lciB1bmEgaGV1csOtc3RpY2EgbcOhcyBhdmFuemFkYS5cbiAgICBjb25zdCBjb2x1bW5XaWR0aHMgPSBjb2x1bW5Db3VudCA+IDAgPyBBcnJheShjb2x1bW5Db3VudCkuZmlsbCgxMDAgLyBjb2x1bW5Db3VudCkgOiBbXTtcblxuXG4gICAgcmV0dXJuIG5ldyBUYWJsZSh7XG4gICAgICAgIHJvd3M6IHJvd3MsXG4gICAgICAgIHdpZHRoOiB7IHNpemU6IDEwMCwgdHlwZTogV2lkdGhUeXBlLlBFUkNFTlRBR0UgfSxcbiAgICAgICAgLy8gU2kgdGllbmVzIGNvbHVtbldpZHRocyBlbiBwb3JjZW50YWplOlxuICAgICAgICBjb2x1bW5XaWR0aHM6IGNvbHVtbldpZHRocy5tYXAodyA9PiAoMTAwIC8gY29sdW1uQ291bnQpICogKDkwMjQgLyAxMDApKSwgLy8gOTAyNCBlcyBhcHJveCBlbCBhbmNobyBkZSBww6FnaW5hIGVuIERYQSBwYXJhIDEwMCVcbiAgICAgICAgLy8gTyB1biBhbmNobyBmaWpvIHBvciBjb2x1bW5hOlxuICAgICAgICAvLyBjb2x1bW5XaWR0aHM6IEFycmF5KGNvbHVtbkNvdW50KS5maWxsKGNvbnZlcnRJbmNoZXNUb1R3aXAoNiAvIGNvbHVtbkNvdW50KSksXG4gICAgICAgIGJvcmRlcnM6IHtcbiAgICAgICAgICAgIHRvcDogeyBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLCBzaXplOiAxLCBjb2xvcjogXCIwMDAwMDBcIiB9LFxuICAgICAgICAgICAgYm90dG9tOiB7IHN0eWxlOiBCb3JkZXJTdHlsZS5TSU5HTEUsIHNpemU6IDEsIGNvbG9yOiBcIjAwMDAwMFwiIH0sXG4gICAgICAgICAgICBsZWZ0OiB7IHN0eWxlOiBCb3JkZXJTdHlsZS5TSU5HTEUsIHNpemU6IDEsIGNvbG9yOiBcIjAwMDAwMFwiIH0sXG4gICAgICAgICAgICByaWdodDogeyBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLCBzaXplOiAxLCBjb2xvcjogXCIwMDAwMDBcIiB9LFxuICAgICAgICAgICAgaW5zaWRlSG9yaXpvbnRhbDogeyBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLCBzaXplOiAxLCBjb2xvcjogXCIwMDAwMDBcIiB9LFxuICAgICAgICAgICAgaW5zaWRlVmVydGljYWw6IHsgc3R5bGU6IEJvcmRlclN0eWxlLlNJTkdMRSwgc2l6ZTogMSwgY29sb3I6IFwiMDAwMDAwXCIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZmxvYXQ6IHsgaG9yaXpvbnRhbEFuY2hvcjogVGFibGVBbmNob3JUeXBlLk1BUkdJTiwgdmVydGljYWxBbmNob3I6IFRhYmxlQW5jaG9yVHlwZS5NQVJHSU4gfSwgLy8gUGFyYSB0YWJsYXMgZmxvdGFudGVzIChtZW5vcyBjb23Dum4pXG4gICAgICAgIC8vIGxheW91dDogVGFibGVMYXlvdXRUeXBlLkZJWEVELCAvLyBQYXJhIHF1ZSBsb3MgYW5jaG9zIGRlIGNvbHVtbmEgc2UgcmVzcGV0ZW4gZXN0cmljdGFtZW50ZVxuICAgIH0pO1xufVxuXG4vLyAtLS0gRnVuY2nDs24gUHJpbmNpcGFsIGRlIEV4cG9ydGFjacOzbiAtLS1cbmV4cG9ydCBjb25zdCBleHBvcnRUb1dvcmQgPSBhc3luYyAobWFya2Rvd25Db250ZW50LCBwcm9ncmFtRGF0YSwgbm90aWZpY2F0aW9uKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1tXT1JEIERPQ1hKUyBFWFBPUlRdIEluaWNpYW5kbyBleHBvcnRhY2nDs24uLi4nKTtcbiAgICBpZiAoIW1hcmtkb3duQ29udGVudCB8fCBtYXJrZG93bkNvbnRlbnQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIG5vdGlmaWNhdGlvbi53YXJuKHsgbWVzc2FnZTogJ0NvbnRlbmlkbyBWYWPDrW8nLCBkZXNjcmlwdGlvbjogJ05vIGhheSBwbGFuIHBhcmEgZXhwb3J0YXIgYSBXb3JkLicgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ1tXT1JEIERPQ1hKUyBFWFBPUlRdIENvbnRlbmlkbyBNYXJrZG93biAoMTAwIGNoYXJzKTonLCBtYXJrZG93bkNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCkpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaHRtbFN0cmluZyA9IG1hcmtlZChtYXJrZG93bkNvbnRlbnQsIHsgYnJlYWtzOiB0cnVlIH0pOyAvLyBicmVha3M6IHRydWUgcGFyYSBxdWUgPGJyPiBzZSBtYW5lamUgbWVqb3JcbiAgICAgICAgY29uc29sZS5sb2coJ1tXT1JEIERPQ1hKUyBFWFBPUlRdIEhUTUwgZ2VuZXJhZG8gKDIwMCBjaGFycyk6JywgaHRtbFN0cmluZy5zdWJzdHJpbmcoMCwgMjAwKSk7XG5cbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBjb25zdCBodG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sU3RyaW5nLCAndGV4dC9odG1sJyk7XG4gICAgICAgIGNvbnN0IGJvZHlFbGVtZW50cyA9IEFycmF5LmZyb20oaHRtbERvYy5ib2R5LmNoaWxkcmVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtXT1JEIERPQ1hKUyBFWFBPUlRdICR7Ym9keUVsZW1lbnRzLmxlbmd0aH0gZWxlbWVudG9zIHByaW5jaXBhbGVzIGVuIEhUTUwgYm9keS5gKTtcblxuICAgICAgICBjb25zdCBkb2NDaGlsZHJlbiA9IFtdO1xuICAgICAgICBjb25zdCBhYnN0cmFjdE51bWJlcmluZyA9IG5ldyBBYnN0cmFjdE51bWJlcmluZyh7IC8vIERlZmluaWNpw7NuIGFic3RyYWN0YSBwYXJhIG51bWVyYWNpw7NuXG4gICAgICAgICAgICBsZXZlbHM6IFtcbiAgICAgICAgICAgICAgICB7IGxldmVsOiAwLCBmb3JtYXQ6IFwiYnVsbGV0XCIsIHRleHQ6IFwiXFx1MjAyMlwiLCBzdHlsZTogeyBwYXJhZ3JhcGg6IHsgaW5kZW50OiB7IGxlZnQ6IGNvbnZlcnRJbmNoZXNUb1R3aXAoMC4yNSksIGhhbmdpbmc6IGNvbnZlcnRJbmNoZXNUb1R3aXAoMC4yNSkgfSB9IH0gfSwgLy8gTml2ZWwgMCBwYXJhIFVMXG4gICAgICAgICAgICAgICAgeyBsZXZlbDogMSwgZm9ybWF0OiBcImJ1bGxldFwiLCB0ZXh0OiBcIlxcdTI1RTZcIiwgc3R5bGU6IHsgcGFyYWdyYXBoOiB7IGluZGVudDogeyBsZWZ0OiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDAuNSksIGhhbmdpbmc6IGNvbnZlcnRJbmNoZXNUb1R3aXAoMC4yNSkgfSB9IH0gfSwgLy8gTml2ZWwgMSBwYXJhIFVMIGFuaWRhZG9cbiAgICAgICAgICAgICAgICAvLyBQdWVkZXMgYcOxYWRpciBtw6FzIG5pdmVsZXMgcGFyYSBVTFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFic3RyYWN0RGVjaW1hbE51bWJlcmluZyA9IG5ldyBBYnN0cmFjdE51bWJlcmluZyh7IC8vIERlZmluaWNpw7NuIGFic3RyYWN0YSBwYXJhIG51bWVyYWNpw7NuIGRlY2ltYWxcbiAgICAgICAgICAgICBsZXZlbHM6IFtcbiAgICAgICAgICAgICAgICB7IGxldmVsOiAwLCBmb3JtYXQ6IFwiZGVjaW1hbFwiLCB0ZXh0OiBcIiUxLlwiLCBzdHlsZTogeyBwYXJhZ3JhcGg6IHsgaW5kZW50OiB7IGxlZnQ6IGNvbnZlcnRJbmNoZXNUb1R3aXAoMC4yNSksIGhhbmdpbmc6IGNvbnZlcnRJbmNoZXNUb1R3aXAoMC4yNSkgfSB9IH0sIHN1ZmZpeDogTGV2ZWxTdWZmaXguVEFCIH0sXG4gICAgICAgICAgICAgICAgeyBsZXZlbDogMSwgZm9ybWF0OiBcImxvd2VyTGV0dGVyXCIsIHRleHQ6IFwiJTIpXCIsIHN0eWxlOiB7IHBhcmFncmFwaDogeyBpbmRlbnQ6IHsgbGVmdDogY29udmVydEluY2hlc1RvVHdpcCgwLjUpLCBoYW5naW5nOiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDAuMjUpIH0gfSB9LCBzdWZmaXg6IExldmVsU3VmZml4LlRBQiB9LFxuICAgICAgICAgICAgICAgIC8vIFB1ZWRlcyBhw7FhZGlyIG3DoXMgbml2ZWxlcyBwYXJhIE9MXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcblxuXG4gICAgICAgIGNvbnN0IGxpc3ROdW1iZXJpbmcgPSBuZXcgTnVtYmVyaW5nKHsgLy8gSW5zdGFuY2lhIGRlIG51bWVyYWNpw7NuXG4gICAgICAgICAgICBjb25maWc6IFtcbiAgICAgICAgICAgICAgICB7IHJlZmVyZW5jZTogXCJidWxsZXQtbnVtYmVyaW5nXCIsIGFic3RyYWN0TnVtYmVyaW5nOiBhYnN0cmFjdE51bWJlcmluZyB9LFxuICAgICAgICAgICAgICAgIHsgcmVmZXJlbmNlOiBcImRlY2ltYWwtbnVtYmVyaW5nXCIsIGFic3RyYWN0TnVtYmVyaW5nOiBhYnN0cmFjdERlY2ltYWxOdW1iZXJpbmcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgYm9keUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1dPUkQgRE9DWEpTIEVYUE9SVF0gUHJvY2VzYW5kbyBlbGVtZW50bzogJHt0YWdOYW1lfWApO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdoMSc6IGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7IGNoaWxkcmVuOiBwYXJzZUh0bWxGb3JEb2N4UnVucyhlbGVtZW50LmlubmVySFRNTCksIGhlYWRpbmc6IEhlYWRpbmdMZXZlbC5IRUFESU5HXzEgfSkpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoMic6IGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7IGNoaWxkcmVuOiBwYXJzZUh0bWxGb3JEb2N4UnVucyhlbGVtZW50LmlubmVySFRNTCksIGhlYWRpbmc6IEhlYWRpbmdMZXZlbC5IRUFESU5HXzIgfSkpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoMyc6IGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7IGNoaWxkcmVuOiBwYXJzZUh0bWxGb3JEb2N4UnVucyhlbGVtZW50LmlubmVySFRNTCksIGhlYWRpbmc6IEhlYWRpbmdMZXZlbC5IRUFESU5HXzMgfSkpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoNCc6IGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7IGNoaWxkcmVuOiBwYXJzZUh0bWxGb3JEb2N4UnVucyhlbGVtZW50LmlubmVySFRNTCksIGhlYWRpbmc6IEhlYWRpbmdMZXZlbC5IRUFESU5HXzQgfSkpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoNSc6IGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7IGNoaWxkcmVuOiBwYXJzZUh0bWxGb3JEb2N4UnVucyhlbGVtZW50LmlubmVySFRNTCksIGhlYWRpbmc6IEhlYWRpbmdMZXZlbC5IRUFESU5HXzUgfSkpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoNic6IGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7IGNoaWxkcmVuOiBwYXJzZUh0bWxGb3JEb2N4UnVucyhlbGVtZW50LmlubmVySFRNTCksIGhlYWRpbmc6IEhlYWRpbmdMZXZlbC5IRUFESU5HXzYgfSkpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwJzogIGRvY0NoaWxkcmVuLnB1c2goY3JlYXRlUGFyYWdyYXBoRnJvbUh0bWxOb2RlKGVsZW1lbnQpKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndWwnOlxuICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGRyZW4pLmZvckVhY2gobGkgPT4geyAvLyBBc3VtaW1vcyBMSSBjb21vIGhpam9zIGRpcmVjdG9zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGkudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChjcmVhdGVQYXJhZ3JhcGhGcm9tSHRtbE5vZGUobGksIHsgcmVmZXJlbmNlOiBcImJ1bGxldC1udW1iZXJpbmdcIiB9LCAwKSk7IC8vIE5pdmVsIDAgcGFyYSBVTCBzaW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29sJzpcbiAgICAgICAgICAgICAgICAgICAgIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZHJlbikuZm9yRWFjaChsaSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGkudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChjcmVhdGVQYXJhZ3JhcGhGcm9tSHRtbE5vZGUobGksIHsgcmVmZXJlbmNlOiBcImRlY2ltYWwtbnVtYmVyaW5nXCIgfSwgMCkpOyAvLyBOaXZlbCAwIHBhcmEgT0wgc2ltcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY3hUYWJsZSA9IGNyZWF0ZVRhYmxlRnJvbUh0bWxUYWJsZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3hUYWJsZSkgZG9jQ2hpbGRyZW4ucHVzaChkb2N4VGFibGUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGNvbnNvbGUud2FybihcIltXT1JEIERPQ1hKUyBFWFBPUlRdIFNlIG9taXRpw7MgdW5hIHRhYmxhIHZhY8OtYSBvIG1hbGZvcm1hZGEuXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnFQYXJhID0gY3JlYXRlUGFyYWdyYXBoRnJvbUh0bWxOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBicVBhcmEub3B0aW9ucy5pbmRlbnQgPSB7IGxlZnQ6IGNvbnZlcnRJbmNoZXNUb1R3aXAoMC41KSB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBQb2Ryw61hcyBkZWZpbmlyIHVuIGVzdGlsbyBwYXJhIGJsb2NrcXVvdGVzIGNvbiBib3JkZXMsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChicVBhcmEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwcmUnOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlVGV4dCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignY29kZScpID8gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjb2RlJykudGV4dENvbnRlbnQgOiBlbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtuZXcgVGV4dFJ1bih7IHRleHQ6IGNvZGVUZXh0IHx8IFwiXCIsIGZvbnQ6IHsgbmFtZTogXCJDb3VyaWVyIE5ld1wiLCBzaXplOiBcIjlwdFwiIH0gfSldLCAvLyBUYW1hw7FvIGV4cGzDrWNpdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRpbmc6IHsgZmlsbDogXCJGMUYxRjFcIiwgdHlwZTogU2hhZGluZ1R5cGUuQ0xFQVIsIGNvbG9yOiBcImF1dG9cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9yZGVyczogeyAvKiBQb2Ryw61hcyBhw7FhZGlyIGJvcmRlcyBwYXJhIHNpbXVsYXIgdW4gPHByZT4gKi8gfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbXVsYWNpw7NuIGRlIEhSIGNvbiB1biBib3JkZSBpbmZlcmlvciBkZSBww6FycmFmb1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiB7IGJvdHRvbTogeyBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLCBzaXplOiA2LCBjb2xvcjogXCJCRkJGQkZcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChuZXcgUGFyYWdyYXBoKFwiXCIpKTsgLy8gRXNwYWNpbyBkZXNwdcOpcyBkZWwgSFJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbV09SRCBET0NYSlMgRVhQT1JUXSBFdGlxdWV0YSBubyBtYW5lamFkYTogJHt0YWdOYW1lfS4gSW50ZW50YW5kbyBjb21vIHDDoXJyYWZvLmApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50ZXh0Q29udGVudCAmJiBlbGVtZW50LnRleHRDb250ZW50LnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChjcmVhdGVQYXJhZ3JhcGhGcm9tSHRtbE5vZGUoZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkb2NDaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXT1JEIERPQ1hKUyBFWFBPUlRdIE5vIHNlIGdlbmVyYXJvbiBlbGVtZW50b3MgcGFyYSBlbCBkb2N1bWVudG8gV29yZC5cIik7XG4gICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKG5ldyBQYXJhZ3JhcGgoXCJFbCBjb250ZW5pZG8gbm8gcHVkbyBzZXIgcHJvY2VzYWRvIHBhcmEgV29yZC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhcIltXT1JEIERPQ1hKUyBFWFBPUlRdIENyZWFuZG8gRG9jdW1lbnQgb2JqZWN0IGNvbiBkb2N4Li4uXCIpO1xuICAgICAgICBjb25zdCBkb2MgPSBuZXcgRG9jdW1lbnQoe1xuICAgICAgICAgICAgbnVtYmVyaW5nOiBsaXN0TnVtYmVyaW5nLCAvLyBSZWdpc3RyYXIgbGEgY29uZmlndXJhY2nDs24gZGUgbnVtZXJhY2nDs25cbiAgICAgICAgICAgIHNlY3Rpb25zOiBbe1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDAuNzUpLCByaWdodDogY29udmVydEluY2hlc1RvVHdpcCgwLjc1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDAuNzUpLCBsZWZ0OiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDAuNzUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGRvY0NoaWxkcmVuLFxuICAgICAgICAgICAgfV0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1dPUkQgRE9DWEpTIEVYUE9SVF0gRW1wYXF1ZXRhbmRvIGRvY3VtZW50byBjb24gUGFja2VyLi4uXCIpO1xuICAgICAgICBQYWNrZXIudG9CbG9iKGRvYykudGhlbihibG9iID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbV09SRCBET0NYSlMgRVhQT1JUXSBCbG9iIERPQ1ggZ2VuZXJhZG8sIHRhbWHDsW86ICR7YmxvYi5zaXplfSBieXRlc2ApO1xuICAgICAgICAgICAgaWYgKGJsb2Iuc2l6ZSA8IDUwMCkgeyAvLyBVbiBET0NYIHZhY8OtbyBzdWVsZSB0ZW5lciB+M0tCLCB1bm8gbXV5IHNpbXBsZSB1biBwb2NvIG3DoXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXN0ZSB1bWJyYWwgZXMgYXJiaXRyYXJpbywgYWp1c3RhIHNpIGVzIG5lY2VzYXJpby5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SRCBET0NYSlMgRVhQT1JUXSBFbCBibG9iIGdlbmVyYWRvIGVzIG11eSBwZXF1ZcOxbywgcG9kcsOtYSBlc3RhciBjYXNpIHZhY8OtbyBvIGNvcnJ1cHRvLlwiKTtcbiAgICAgICAgICAgICAgICAgLy8gUG9kcsOtYXMgbm8gZGVzY2FyZ2FyIHNpIGVzIG11eSBwZXF1ZcOxbyBvIG1vc3RyYXIgdW5hIGFkdmVydGVuY2lhIGFkaWNpb25hbC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7cHJvZ3JhbURhdGE/LmRlZ3JlZT8ucmVwbGFjZSgvXFxzKy9nLCAnXycpIHx8ICdwbGFuX2N1cnJpY3VsYXInfV8ke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCl9LmRvY3hgO1xuICAgICAgICAgICAgc2F2ZUFzKGJsb2IsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1dPUkQgRE9DWEpTIEVYUE9SVF0gc2F2ZUFzIGxsYW1hZG8uXCIpO1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uLnN1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdXb3JkIEV4cG9ydGFkbyAoZG9jeCknLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRWwgcGxhbiBkZWJlcsOtYSBlc3RhciBkZXNjYXJnw6FuZG9zZSBjb21vICR7ZmlsZU5hbWV9LmAsXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tUmlnaHQnLFxuICAgICAgICAgICAgICAgIGljb246IDxDbG91ZERvd25sb2FkT3V0bGluZWQgc3R5bGU9e3sgY29sb3I6ICcjNTJjNDFhJyB9fSAvPixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaChwYWNrRXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1dPUkQgRE9DWEpTIEVYUE9SVF0gRXJyb3IgZW4gUGFja2VyLnRvQmxvYjonLCBwYWNrRXJyb3IpO1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uLmVycm9yKHsgbWVzc2FnZTogJ0Vycm9yIEVtcGFxdWV0YW5kbyBXb3JkJywgZGVzY3JpcHRpb246IHBhY2tFcnJvci5tZXNzYWdlIHx8ICdGYWxsbyBhbCBlbXBhcXVldGFyIGVsIERPQ1guJyB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbV09SRCBET0NYSlMgRVhQT1JUXSBFcnJvciBHRU5FUkFMOicsIGVycm9yKTtcbiAgICAgICAgbm90aWZpY2F0aW9uLmVycm9yKHsgbWVzc2FnZTogJ0Vycm9yIGFsIEV4cG9ydGFyIFdvcmQnLCBkZXNjcmlwdGlvbjogZXJyb3IubWVzc2FnZSB8fCAnUHJvYmxlbWEgYWwgZ2VuZXJhciBhcmNoaXZvIERPQ1guJyB9KTtcbiAgICB9XG59OyJdLCJuYW1lcyI6WyJEb2N1bWVudCIsIlBhY2tlciIsIlBhcmFncmFwaCIsIlRleHRSdW4iLCJIZWFkaW5nTGV2ZWwiLCJUYWJsZSIsIlRhYmxlUm93IiwiVGFibGVDZWxsIiwiV2lkdGhUeXBlIiwiQm9yZGVyU3R5bGUiLCJBbGlnbm1lbnRUeXBlIiwiY29udmVydEluY2hlc1RvVHdpcCIsIlNoYWRpbmdUeXBlIiwiVmVydGljYWxBbGlnbiIsIk51bWJlcmluZyIsIkluZGVudCIsIkxldmVsU3VmZml4IiwiU3R5bGVMZXZlbCIsIkFic3RyYWN0TnVtYmVyaW5nIiwic2F2ZUFzIiwibWFya2VkIiwiQ2xvdWREb3dubG9hZE91dGxpbmVkIiwicGFyc2VIdG1sRm9yRG9jeFJ1bnMiLCJodG1sU3RyaW5nIiwicnVucyIsInRlbXBEaXYiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJ0cmltIiwicHJvY2Vzc05vZGUiLCJjdXJyZW50Tm9kZSIsImN1cnJlbnRPcHRpb25zIiwibm9kZVR5cGUiLCJOb2RlIiwiVEVYVF9OT0RFIiwidGV4dENvbnRlbnQiLCJsZW5ndGgiLCJicmVhayIsInB1c2giLCJ0ZXh0IiwiRUxFTUVOVF9OT0RFIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwibmV3T3B0aW9ucyIsImJvbGQiLCJpdGFsaWNzIiwidW5kZXJsaW5lIiwiZm9udCIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJjaGlsZE5vZGVzIiwiZm9yRWFjaCIsImNoaWxkIiwiY3JlYXRlUGFyYWdyYXBoRnJvbUh0bWxOb2RlIiwiaHRtbE5vZGUiLCJudW1iZXJpbmdDb25maWciLCJsZXZlbCIsInBhcmFncmFwaE9wdGlvbnMiLCJjaGlsZHJlbiIsIm51bWJlcmluZyIsInJlZmVyZW5jZSIsImNyZWF0ZVRhYmxlRnJvbUh0bWxUYWJsZSIsImh0bWxUYWJsZU5vZGUiLCJyb3dzIiwiY29sdW1uQ291bnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwidHJOb2RlIiwiY2VsbHMiLCJjdXJyZW50Q29sdW1uQ291bnRJblJvdyIsInRoTm9kZSIsImFsaWdubWVudCIsIkNFTlRFUiIsInNoYWRpbmciLCJmaWxsIiwidHlwZSIsIkNMRUFSIiwiY29sb3IiLCJ2ZXJ0aWNhbEFsaWduIiwidGFibGVIZWFkZXIiLCJ0ZE5vZGUiLCJjZWxsUGFyYWdyYXBocyIsImNlbGxIdG1sUGFydHMiLCJzcGxpdCIsInBhcnQiLCJUT1AiLCJjb2x1bW5XaWR0aHMiLCJ3aWR0aCIsInNpemUiLCJQRVJDRU5UQUdFIiwibWFwIiwidyIsImJvcmRlcnMiLCJ0b3AiLCJzdHlsZSIsIlNJTkdMRSIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImluc2lkZUhvcml6b250YWwiLCJpbnNpZGVWZXJ0aWNhbCIsImV4cG9ydFRvV29yZCIsIm1hcmtkb3duQ29udGVudCIsInByb2dyYW1EYXRhIiwibm90aWZpY2F0aW9uIiwiY29uc29sZSIsImxvZyIsIndhcm4iLCJtZXNzYWdlIiwiZGVzY3JpcHRpb24iLCJzdWJzdHJpbmciLCJicmVha3MiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJodG1sRG9jIiwicGFyc2VGcm9tU3RyaW5nIiwiYm9keUVsZW1lbnRzIiwiYm9keSIsImRvY0NoaWxkcmVuIiwiYWJzdHJhY3ROdW1iZXJpbmciLCJsZXZlbHMiLCJmb3JtYXQiLCJwYXJhZ3JhcGgiLCJpbmRlbnQiLCJoYW5naW5nIiwiYWJzdHJhY3REZWNpbWFsTnVtYmVyaW5nIiwic3VmZml4IiwiVEFCIiwibGlzdE51bWJlcmluZyIsImNvbmZpZyIsImVsZW1lbnQiLCJoZWFkaW5nIiwiSEVBRElOR18xIiwiSEVBRElOR18yIiwiSEVBRElOR18zIiwiSEVBRElOR180IiwiSEVBRElOR181IiwiSEVBRElOR182IiwibGkiLCJkb2N4VGFibGUiLCJicVBhcmEiLCJvcHRpb25zIiwiY29kZVRleHQiLCJxdWVyeVNlbGVjdG9yIiwiYm9yZGVyIiwiZG9jIiwic2VjdGlvbnMiLCJwcm9wZXJ0aWVzIiwicGFnZSIsIm1hcmdpbiIsInRvQmxvYiIsInRoZW4iLCJibG9iIiwiZmlsZU5hbWUiLCJkZWdyZWUiLCJyZXBsYWNlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2xpY2UiLCJzdWNjZXNzIiwicGxhY2VtZW50IiwiaWNvbiIsImNhdGNoIiwicGFja0Vycm9yIiwiZXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/exportWord.js\n"));

/***/ })

});