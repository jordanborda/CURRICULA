"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./components/exportPdf.js":
/*!*********************************!*\
  !*** ./components/exportPdf.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportToPdf: () => (/* binding */ exportToPdf)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/.pnpm/react@19.1.0/node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf */ \"(pages-dir-browser)/./node_modules/.pnpm/jspdf@3.0.1/node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jspdf-autotable */ \"(pages-dir-browser)/./node_modules/.pnpm/jspdf-autotable@5.0.2_jspdf@3.0.1/node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! marked */ \"(pages-dir-browser)/./node_modules/.pnpm/marked@15.0.12/node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var _barrel_optimize_names_CloudDownloadOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=CloudDownloadOutlined!=!@ant-design/icons */ \"(pages-dir-browser)/__barrel_optimize__?names=CloudDownloadOutlined!=!./node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@ant-design/icons/es/index.js\");\n// File: components/exportPdf.js\n\n\n// No importes 'jspdf-autotable' directamente para el side-effect aquí.\n// En su lugar, importaremos lo que necesitamos de él.\n // Importa la función autoTable\n\n\nconst DEFAULT_FONT_SIZE_PT = 10;\nconst TABLE_FONT_SIZE_PT = 6;\nconst HEADER_FONT_SIZE_PT = {\n    H1: 16,\n    H2: 14,\n    H3: 12,\n    H4: 10,\n    H5: 9,\n    H6: 8\n};\nconst LINE_HEIGHT_FACTOR = 1.2;\nconst MARGIN_PT = 30;\nfunction addText(doc, text, x, y, maxWidth) {\n    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};\n    // ... (mantener la función addText como antes)\n    const { fontSize = DEFAULT_FONT_SIZE_PT, fontStyle = 'normal', isHtml = false } = options;\n    doc.setFontSize(fontSize);\n    doc.setFont(undefined, fontStyle);\n    let processedText = text;\n    if (isHtml) {\n        processedText = text.replace(/<br\\s*\\/?>/gi, '\\n');\n        const tempDiv = document.createElement('div');\n        tempDiv.innerHTML = processedText;\n        processedText = tempDiv.textContent || tempDiv.innerText || \"\";\n    }\n    const lines = doc.splitTextToSize(processedText, maxWidth);\n    const textHeight = lines.length * fontSize * LINE_HEIGHT_FACTOR;\n    if (y + textHeight > doc.internal.pageSize.height - MARGIN_PT) {\n        doc.addPage();\n        y = MARGIN_PT;\n    }\n    doc.text(lines, x, y, {\n        lineHeightFactor: LINE_HEIGHT_FACTOR\n    });\n    return y + textHeight;\n}\nconst exportToPdf = async (markdownContent, programData, notification)=>{\n    if (!markdownContent) {\n        notification.warn({\n            message: 'Contenido Vacío',\n            description: 'No hay plan para exportar a PDF.'\n        });\n        return;\n    }\n    try {\n        var _programData_degree;\n        const htmlString = (0,marked__WEBPACK_IMPORTED_MODULE_3__.marked)(markdownContent);\n        const parser = new DOMParser();\n        const htmlDoc = parser.parseFromString(htmlString, 'text/html');\n        const bodyElements = Array.from(htmlDoc.body.children);\n        const doc = new jspdf__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n            orientation: 'p',\n            unit: 'pt',\n            format: 'a4'\n        });\n        // No es necesario llamar a applyPlugin(jsPDF) si importas autoTable como función\n        // Ahora llamarás a autoTable(doc, { ... }) en lugar de doc.autoTable({ ... })\n        let currentY = MARGIN_PT;\n        const contentWidth = doc.internal.pageSize.width - 2 * MARGIN_PT;\n        for (const element of bodyElements){\n            if (currentY > doc.internal.pageSize.height - MARGIN_PT - 20) {\n                doc.addPage();\n                currentY = MARGIN_PT;\n            }\n            const tagName = element.tagName.toUpperCase();\n            if (HEADER_FONT_SIZE_PT[tagName]) {\n                currentY = addText(doc, element.textContent, MARGIN_PT, currentY, contentWidth, {\n                    fontSize: HEADER_FONT_SIZE_PT[tagName],\n                    fontStyle: 'bold'\n                });\n                currentY += 5;\n            } else if (tagName === 'P') {\n                currentY = addText(doc, element.innerHTML, MARGIN_PT, currentY, contentWidth, {\n                    isHtml: true\n                });\n                currentY += 5;\n            } else if (tagName === 'UL' || tagName === 'OL') {\n                Array.from(element.children).forEach((li, idx)=>{\n                    if (currentY > doc.internal.pageSize.height - MARGIN_PT - 10) {\n                        doc.addPage();\n                        currentY = MARGIN_PT;\n                    }\n                    const prefix = tagName === 'UL' ? '• ' : \"\".concat(idx + 1, \". \");\n                    currentY = addText(doc, prefix + li.innerHTML, MARGIN_PT + 10, currentY, contentWidth - 10, {\n                        isHtml: true\n                    });\n                });\n                currentY += 5;\n            } else if (tagName === 'BLOCKQUOTE') {\n                doc.setFillColor(240, 240, 240);\n                const tempY = currentY;\n                const finalY = addText(doc, element.innerHTML, MARGIN_PT + 5, currentY, contentWidth - 10, {\n                    fontSize: DEFAULT_FONT_SIZE_PT - 1,\n                    fontStyle: 'italic',\n                    isHtml: true\n                });\n                doc.rect(MARGIN_PT, tempY - (DEFAULT_FONT_SIZE_PT - 1) / 2, 3, finalY - tempY + (DEFAULT_FONT_SIZE_PT - 1) / 2, 'F');\n                currentY = finalY + 5;\n            } else if (tagName === 'PRE' || tagName === 'CODE' && element.parentElement.tagName !== 'PRE') {\n                doc.setFont('courier', 'normal');\n                currentY = addText(doc, element.textContent, MARGIN_PT, currentY, contentWidth, {\n                    fontSize: DEFAULT_FONT_SIZE_PT - 2\n                });\n                doc.setFont(undefined, 'normal');\n                currentY += 5;\n            } else if (tagName === 'TABLE') {\n                const headRows = [];\n                element.querySelectorAll('thead tr').forEach((trNode)=>{\n                    const row = [];\n                    trNode.querySelectorAll('th').forEach((thNode)=>row.push(thNode.textContent.trim()));\n                    headRows.push(row);\n                });\n                const bodyRows = [];\n                element.querySelectorAll('tbody tr').forEach((trNode)=>{\n                    const row = [];\n                    trNode.querySelectorAll('td').forEach((tdNode)=>{\n                        const cellHTML = tdNode.innerHTML.replace(/<br\\s*\\/?>/gi, '\\n');\n                        const tempDiv = document.createElement('div');\n                        tempDiv.innerHTML = cellHTML;\n                        row.push(tempDiv.textContent || tempDiv.innerText || \"\");\n                    });\n                    bodyRows.push(row);\n                });\n                if (currentY + 20 > doc.internal.pageSize.height - MARGIN_PT) {\n                    doc.addPage();\n                    currentY = MARGIN_PT;\n                }\n                // CAMBIO AQUÍ: Llama a autoTable como una función, pasando 'doc'\n                (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(doc, {\n                    head: headRows,\n                    body: bodyRows,\n                    startY: currentY,\n                    theme: 'grid',\n                    styles: {\n                        fontSize: TABLE_FONT_SIZE_PT,\n                        cellPadding: 1.5,\n                        overflow: 'linebreak'\n                    },\n                    headStyles: {\n                        fillColor: [\n                            41,\n                            128,\n                            185\n                        ],\n                        textColor: [\n                            255,\n                            255,\n                            255\n                        ],\n                        fontStyle: 'bold',\n                        fontSize: TABLE_FONT_SIZE_PT + 1\n                    },\n                    margin: {\n                        left: MARGIN_PT,\n                        right: MARGIN_PT\n                    },\n                    tableWidth: 'auto'\n                });\n                currentY = doc.lastAutoTable.finalY + 10;\n            } else if (tagName === 'HR') {\n                if (currentY + 10 > doc.internal.pageSize.height - MARGIN_PT) {\n                    doc.addPage();\n                    currentY = MARGIN_PT;\n                }\n                doc.setDrawColor(180, 180, 180);\n                doc.line(MARGIN_PT, currentY, doc.internal.pageSize.width - MARGIN_PT, currentY);\n                currentY += 10;\n            } else if (element.textContent.trim()) {\n                console.warn(\"Elemento PDF no manejado explícitamente:\", tagName, element.textContent.substring(0, 30));\n                currentY = addText(doc, element.innerHTML, MARGIN_PT, currentY, contentWidth, {\n                    isHtml: true\n                });\n                currentY += 5;\n            }\n        }\n        const fileName = \"\".concat((programData === null || programData === void 0 ? void 0 : (_programData_degree = programData.degree) === null || _programData_degree === void 0 ? void 0 : _programData_degree.replace(/\\s+/g, '_')) || 'plan_curricular', \"_\").concat(new Date().toISOString().slice(0, 10), \".pdf\");\n        doc.save(fileName);\n        notification.success({\n            message: 'PDF Exportado',\n            description: \"El plan de estudios se ha guardado como \".concat(fileName, \".\"),\n            placement: 'bottomRight',\n            icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_CloudDownloadOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__.CloudDownloadOutlined, {\n                style: {\n                    color: '#52c41a'\n                }\n            }, void 0, false, {\n                fileName: \"/home/jordan/Documents/Software Directrices/CURRICULAFORGE/components/exportPdf.js\",\n                lineNumber: 176,\n                columnNumber: 13\n            }, undefined)\n        });\n    } catch (error) {\n        console.error('Error al generar PDF:', error);\n        notification.error({\n            message: 'Error al Exportar PDF',\n            description: error.message || 'Ocurrió un problema al generar el archivo PDF.',\n            placement: 'bottomRight'\n        });\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvZXhwb3J0UGRmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxnQ0FBZ0M7O0FBQ047QUFDMUIsdUVBQXVFO0FBQ3ZFLHNEQUFzRDtBQUNkLENBQUMsK0JBQStCO0FBQ3hDO0FBQzBCO0FBRTFELE1BQU1JLHVCQUF1QjtBQUM3QixNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMsc0JBQXNCO0lBQUVDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFHQyxJQUFJO0FBQUU7QUFDM0UsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLFlBQVk7QUFFbEIsU0FBU0MsUUFBUUMsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxRQUFRO1FBQUVDLFVBQUFBLGlFQUFVLENBQUM7SUFDckQsK0NBQStDO0lBQy9DLE1BQU0sRUFDSkMsV0FBV2xCLG9CQUFvQixFQUMvQm1CLFlBQVksUUFBUSxFQUNwQkMsU0FBUyxLQUFLLEVBQ2YsR0FBR0g7SUFFSkwsSUFBSVMsV0FBVyxDQUFDSDtJQUNoQk4sSUFBSVUsT0FBTyxDQUFDQyxXQUFXSjtJQUV2QixJQUFJSyxnQkFBZ0JYO0lBQ3BCLElBQUlPLFFBQVE7UUFDVkksZ0JBQWdCWCxLQUFLWSxPQUFPLENBQUMsZ0JBQWdCO1FBQzdDLE1BQU1DLFVBQVVDLFNBQVNDLGFBQWEsQ0FBQztRQUN2Q0YsUUFBUUcsU0FBUyxHQUFHTDtRQUNwQkEsZ0JBQWdCRSxRQUFRSSxXQUFXLElBQUlKLFFBQVFLLFNBQVMsSUFBSTtJQUM5RDtJQUVBLE1BQU1DLFFBQVFwQixJQUFJcUIsZUFBZSxDQUFDVCxlQUFlUjtJQUNqRCxNQUFNa0IsYUFBYUYsTUFBTUcsTUFBTSxHQUFHakIsV0FBV1Q7SUFFN0MsSUFBSU0sSUFBSW1CLGFBQWF0QixJQUFJd0IsUUFBUSxDQUFDQyxRQUFRLENBQUNDLE1BQU0sR0FBRzVCLFdB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QixXQUFXbUQsVUFBVUMsY0FBYztvQkFBQzFDLFFBQVE7Z0JBQUk7Z0JBQzNGeUMsWUFBWTtZQUNkO1FBQ0Y7UUFFQSxNQUFNMkMsV0FBVyxHQUFxRSxPQUFsRTdELENBQUFBLHdCQUFBQSxtQ0FBQUEsc0JBQUFBLFlBQWE4RCxNQUFNLGNBQW5COUQsMENBQUFBLG9CQUFxQmxCLE9BQU8sQ0FBQyxRQUFRLFNBQVEsbUJBQWtCLEtBQXlDLE9BQXRDLElBQUlpRixPQUFPQyxXQUFXLEdBQUdDLEtBQUssQ0FBQyxHQUFHLEtBQUk7UUFDNUhoRyxJQUFJaUcsSUFBSSxDQUFDTDtRQUVUNUQsYUFBYWtFLE9BQU8sQ0FBQztZQUNuQmhFLFNBQVM7WUFDVEMsYUFBYSwyQ0FBb0QsT0FBVHlELFVBQVM7WUFDakVPLFdBQVc7WUFDWEMsb0JBQU0sOERBQUNqSCxnSEFBcUJBO2dCQUFDa0gsT0FBTztvQkFBRUMsT0FBTztnQkFBVTs7Ozs7O1FBQ3pEO0lBRUYsRUFBRSxPQUFPQyxPQUFPO1FBQ2RiLFFBQVFhLEtBQUssQ0FBQyx5QkFBeUJBO1FBQ3ZDdkUsYUFBYXVFLEtBQUssQ0FBQztZQUNqQnJFLFNBQVM7WUFDVEMsYUFBYW9FLE1BQU1yRSxPQUFPLElBQUk7WUFDOUJpRSxXQUFXO1FBQ2I7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9ob21lL2pvcmRhbi9Eb2N1bWVudHMvU29mdHdhcmUgRGlyZWN0cmljZXMvQ1VSUklDVUxBRk9SR0UvY29tcG9uZW50cy9leHBvcnRQZGYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZTogY29tcG9uZW50cy9leHBvcnRQZGYuanNcbmltcG9ydCBqc1BERiBmcm9tICdqc3BkZic7XG4vLyBObyBpbXBvcnRlcyAnanNwZGYtYXV0b3RhYmxlJyBkaXJlY3RhbWVudGUgcGFyYSBlbCBzaWRlLWVmZmVjdCBhcXXDrS5cbi8vIEVuIHN1IGx1Z2FyLCBpbXBvcnRhcmVtb3MgbG8gcXVlIG5lY2VzaXRhbW9zIGRlIMOpbC5cbmltcG9ydCBhdXRvVGFibGUgZnJvbSAnanNwZGYtYXV0b3RhYmxlJzsgLy8gSW1wb3J0YSBsYSBmdW5jacOzbiBhdXRvVGFibGVcbmltcG9ydCB7IG1hcmtlZCB9IGZyb20gJ21hcmtlZCc7XG5pbXBvcnQgeyBDbG91ZERvd25sb2FkT3V0bGluZWQgfSBmcm9tICdAYW50LWRlc2lnbi9pY29ucyc7XG5cbmNvbnN0IERFRkFVTFRfRk9OVF9TSVpFX1BUID0gMTA7XG5jb25zdCBUQUJMRV9GT05UX1NJWkVfUFQgPSA2O1xuY29uc3QgSEVBREVSX0ZPTlRfU0laRV9QVCA9IHsgSDE6IDE2LCBIMjogMTQsIEgzOiAxMiwgSDQ6IDEwLCBINTogOSwgSDY6IDggfTtcbmNvbnN0IExJTkVfSEVJR0hUX0ZBQ1RPUiA9IDEuMjtcbmNvbnN0IE1BUkdJTl9QVCA9IDMwO1xuXG5mdW5jdGlvbiBhZGRUZXh0KGRvYywgdGV4dCwgeCwgeSwgbWF4V2lkdGgsIG9wdGlvbnMgPSB7fSkge1xuICAvLyAuLi4gKG1hbnRlbmVyIGxhIGZ1bmNpw7NuIGFkZFRleHQgY29tbyBhbnRlcylcbiAgY29uc3Qge1xuICAgIGZvbnRTaXplID0gREVGQVVMVF9GT05UX1NJWkVfUFQsXG4gICAgZm9udFN0eWxlID0gJ25vcm1hbCcsXG4gICAgaXNIdG1sID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG5cbiAgZG9jLnNldEZvbnRTaXplKGZvbnRTaXplKTtcbiAgZG9jLnNldEZvbnQodW5kZWZpbmVkLCBmb250U3R5bGUpO1xuXG4gIGxldCBwcm9jZXNzZWRUZXh0ID0gdGV4dDtcbiAgaWYgKGlzSHRtbCkge1xuICAgIHByb2Nlc3NlZFRleHQgPSB0ZXh0LnJlcGxhY2UoLzxiclxccypcXC8/Pi9naSwgJ1xcbicpO1xuICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0ZW1wRGl2LmlubmVySFRNTCA9IHByb2Nlc3NlZFRleHQ7XG4gICAgcHJvY2Vzc2VkVGV4dCA9IHRlbXBEaXYudGV4dENvbnRlbnQgfHwgdGVtcERpdi5pbm5lclRleHQgfHwgXCJcIjtcbiAgfVxuXG4gIGNvbnN0IGxpbmVzID0gZG9jLnNwbGl0VGV4dFRvU2l6ZShwcm9jZXNzZWRUZXh0LCBtYXhXaWR0aCk7XG4gIGNvbnN0IHRleHRIZWlnaHQgPSBsaW5lcy5sZW5ndGggKiBmb250U2l6ZSAqIExJTkVfSEVJR0hUX0ZBQ1RPUjtcblxuICBpZiAoeSArIHRleHRIZWlnaHQgPiBkb2MuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0IC0gTUFSR0lOX1BUKSB7XG4gICAgZG9jLmFkZFBhZ2UoKTtcbiAgICB5ID0gTUFSR0lOX1BUO1xuICB9XG4gIGRvYy50ZXh0KGxpbmVzLCB4LCB5LCB7IGxpbmVIZWlnaHRGYWN0b3I6IExJTkVfSEVJR0hUX0ZBQ1RPUiB9KTtcbiAgcmV0dXJuIHkgKyB0ZXh0SGVpZ2h0O1xufVxuXG5leHBvcnQgY29uc3QgZXhwb3J0VG9QZGYgPSBhc3luYyAobWFya2Rvd25Db250ZW50LCBwcm9ncmFtRGF0YSwgbm90aWZpY2F0aW9uKSA9PiB7XG4gIGlmICghbWFya2Rvd25Db250ZW50KSB7XG4gICAgbm90aWZpY2F0aW9uLndhcm4oe1xuICAgICAgbWVzc2FnZTogJ0NvbnRlbmlkbyBWYWPDrW8nLFxuICAgICAgZGVzY3JpcHRpb246ICdObyBoYXkgcGxhbiBwYXJhIGV4cG9ydGFyIGEgUERGLicsXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBodG1sU3RyaW5nID0gbWFya2VkKG1hcmtkb3duQ29udGVudCk7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgIGNvbnN0IGh0bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGh0bWxTdHJpbmcsICd0ZXh0L2h0bWwnKTtcbiAgICBjb25zdCBib2R5RWxlbWVudHMgPSBBcnJheS5mcm9tKGh0bWxEb2MuYm9keS5jaGlsZHJlbik7XG5cbiAgICBjb25zdCBkb2MgPSBuZXcganNQREYoe1xuICAgICAgb3JpZW50YXRpb246ICdwJyxcbiAgICAgIHVuaXQ6ICdwdCcsXG4gICAgICBmb3JtYXQ6ICdhNCcsXG4gICAgfSk7XG5cbiAgICAvLyBObyBlcyBuZWNlc2FyaW8gbGxhbWFyIGEgYXBwbHlQbHVnaW4oanNQREYpIHNpIGltcG9ydGFzIGF1dG9UYWJsZSBjb21vIGZ1bmNpw7NuXG4gICAgLy8gQWhvcmEgbGxhbWFyw6FzIGEgYXV0b1RhYmxlKGRvYywgeyAuLi4gfSkgZW4gbHVnYXIgZGUgZG9jLmF1dG9UYWJsZSh7IC4uLiB9KVxuXG4gICAgbGV0IGN1cnJlbnRZID0gTUFSR0lOX1BUO1xuICAgIGNvbnN0IGNvbnRlbnRXaWR0aCA9IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS53aWR0aCAtIDIgKiBNQVJHSU5fUFQ7XG5cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYm9keUVsZW1lbnRzKSB7XG4gICAgICBpZiAoY3VycmVudFkgPiBkb2MuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0IC0gTUFSR0lOX1BUIC0gMjApIHtcbiAgICAgICAgIGRvYy5hZGRQYWdlKCk7XG4gICAgICAgICBjdXJyZW50WSA9IE1BUkdJTl9QVDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICBpZiAoSEVBREVSX0ZPTlRfU0laRV9QVFt0YWdOYW1lXSkge1xuICAgICAgICBjdXJyZW50WSA9IGFkZFRleHQoZG9jLCBlbGVtZW50LnRleHRDb250ZW50LCBNQVJHSU5fUFQsIGN1cnJlbnRZLCBjb250ZW50V2lkdGgsIHtcbiAgICAgICAgICBmb250U2l6ZTogSEVBREVSX0ZPTlRfU0laRV9QVFt0YWdOYW1lXSxcbiAgICAgICAgICBmb250U3R5bGU6ICdib2xkJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnRZICs9IDU7XG4gICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdQJykge1xuICAgICAgICBjdXJyZW50WSA9IGFkZFRleHQoZG9jLCBlbGVtZW50LmlubmVySFRNTCwgTUFSR0lOX1BULCBjdXJyZW50WSwgY29udGVudFdpZHRoLCB7IGlzSHRtbDogdHJ1ZSB9KTtcbiAgICAgICAgY3VycmVudFkgKz0gNTtcbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ1VMJyB8fCB0YWdOYW1lID09PSAnT0wnKSB7XG4gICAgICAgIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZHJlbikuZm9yRWFjaCgobGksIGlkeCkgPT4ge1xuICAgICAgICAgIGlmIChjdXJyZW50WSA+IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQgLSBNQVJHSU5fUFQgLSAxMCkge1xuICAgICAgICAgICAgZG9jLmFkZFBhZ2UoKTsgY3VycmVudFkgPSBNQVJHSU5fUFQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHRhZ05hbWUgPT09ICdVTCcgPyAn4oCiICcgOiBgJHtpZHggKyAxfS4gYDtcbiAgICAgICAgICBjdXJyZW50WSA9IGFkZFRleHQoZG9jLCBwcmVmaXggKyBsaS5pbm5lckhUTUwsIE1BUkdJTl9QVCArIDEwLCBjdXJyZW50WSwgY29udGVudFdpZHRoIC0gMTAsIHsgaXNIdG1sOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudFkgKz0gNTtcbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ0JMT0NLUVVPVEUnKSB7XG4gICAgICAgIGRvYy5zZXRGaWxsQ29sb3IoMjQwLCAyNDAsIDI0MCk7XG4gICAgICAgIGNvbnN0IHRlbXBZID0gY3VycmVudFk7XG4gICAgICAgIGNvbnN0IGZpbmFsWSA9IGFkZFRleHQoZG9jLCBlbGVtZW50LmlubmVySFRNTCwgTUFSR0lOX1BUICsgNSwgY3VycmVudFksIGNvbnRlbnRXaWR0aCAtIDEwLCB7IGZvbnRTaXplOiBERUZBVUxUX0ZPTlRfU0laRV9QVCAtMSwgZm9udFN0eWxlOiAnaXRhbGljJywgaXNIdG1sOiB0cnVlIH0pO1xuICAgICAgICBkb2MucmVjdChNQVJHSU5fUFQsIHRlbXBZIC0gKERFRkFVTFRfRk9OVF9TSVpFX1BUIC0xKS8yICwgMywgZmluYWxZIC0gdGVtcFkgKyAoREVGQVVMVF9GT05UX1NJWkVfUFQgLTEpLzIsICdGJyk7XG4gICAgICAgIGN1cnJlbnRZID0gZmluYWxZICsgNTtcbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ1BSRScgfHwgKHRhZ05hbWUgPT09ICdDT0RFJyAmJiBlbGVtZW50LnBhcmVudEVsZW1lbnQudGFnTmFtZSAhPT0gJ1BSRScpKSB7XG4gICAgICAgIGRvYy5zZXRGb250KCdjb3VyaWVyJywgJ25vcm1hbCcpO1xuICAgICAgICBjdXJyZW50WSA9IGFkZFRleHQoZG9jLCBlbGVtZW50LnRleHRDb250ZW50LCBNQVJHSU5fUFQsIGN1cnJlbnRZLCBjb250ZW50V2lkdGgsIHsgZm9udFNpemU6IERFRkFVTFRfRk9OVF9TSVpFX1BUIC0gMiB9KTtcbiAgICAgICAgZG9jLnNldEZvbnQodW5kZWZpbmVkLCAnbm9ybWFsJyk7XG4gICAgICAgIGN1cnJlbnRZICs9IDU7XG4gICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdUQUJMRScpIHtcbiAgICAgICAgY29uc3QgaGVhZFJvd3MgPSBbXTtcbiAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCd0aGVhZCB0cicpLmZvckVhY2godHJOb2RlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICAgICAgdHJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RoJykuZm9yRWFjaCh0aE5vZGUgPT4gcm93LnB1c2godGhOb2RlLnRleHRDb250ZW50LnRyaW0oKSkpO1xuICAgICAgICAgICAgaGVhZFJvd3MucHVzaChyb3cpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBib2R5Um93cyA9IFtdO1xuICAgICAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Rib2R5IHRyJykuZm9yRWFjaCh0ck5vZGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gW107XG4gICAgICAgICAgICB0ck5vZGUucXVlcnlTZWxlY3RvckFsbCgndGQnKS5mb3JFYWNoKHRkTm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbEhUTUwgPSB0ZE5vZGUuaW5uZXJIVE1MLnJlcGxhY2UoLzxiclxccypcXC8/Pi9naSwgJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IGNlbGxIVE1MO1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKHRlbXBEaXYudGV4dENvbnRlbnQgfHwgdGVtcERpdi5pbm5lclRleHQgfHwgXCJcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJvZHlSb3dzLnB1c2gocm93KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY3VycmVudFkgKyAyMCA+IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQgLSBNQVJHSU5fUFQpIHtcbiAgICAgICAgICAgIGRvYy5hZGRQYWdlKCk7XG4gICAgICAgICAgICBjdXJyZW50WSA9IE1BUkdJTl9QVDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENBTUJJTyBBUVXDjTogTGxhbWEgYSBhdXRvVGFibGUgY29tbyB1bmEgZnVuY2nDs24sIHBhc2FuZG8gJ2RvYydcbiAgICAgICAgYXV0b1RhYmxlKGRvYywgeyAvLyA8LS0tIENBTUJJTyBJTVBPUlRBTlRFXG4gICAgICAgICAgaGVhZDogaGVhZFJvd3MsXG4gICAgICAgICAgYm9keTogYm9keVJvd3MsXG4gICAgICAgICAgc3RhcnRZOiBjdXJyZW50WSxcbiAgICAgICAgICB0aGVtZTogJ2dyaWQnLFxuICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgZm9udFNpemU6IFRBQkxFX0ZPTlRfU0laRV9QVCxcbiAgICAgICAgICAgIGNlbGxQYWRkaW5nOiAxLjUsXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2xpbmVicmVhaycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWFkU3R5bGVzOiB7XG4gICAgICAgICAgICBmaWxsQ29sb3I6IFs0MSwgMTI4LCAxODVdLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICAgICAgICBmb250U3R5bGU6ICdib2xkJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiBUQUJMRV9GT05UX1NJWkVfUFQgKyAxLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFyZ2luOiB7IGxlZnQ6IE1BUkdJTl9QVCwgcmlnaHQ6IE1BUkdJTl9QVCB9LFxuICAgICAgICAgIHRhYmxlV2lkdGg6ICdhdXRvJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnRZID0gZG9jLmxhc3RBdXRvVGFibGUuZmluYWxZICsgMTA7XG4gICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdIUicpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRZICsgMTAgPiBkb2MuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0IC0gTUFSR0lOX1BUKSB7XG4gICAgICAgICAgICBkb2MuYWRkUGFnZSgpOyBjdXJyZW50WSA9IE1BUkdJTl9QVDtcbiAgICAgICAgfVxuICAgICAgICBkb2Muc2V0RHJhd0NvbG9yKDE4MCwgMTgwLCAxODApO1xuICAgICAgICBkb2MubGluZShNQVJHSU5fUFQsIGN1cnJlbnRZLCBkb2MuaW50ZXJuYWwucGFnZVNpemUud2lkdGggLSBNQVJHSU5fUFQsIGN1cnJlbnRZKTtcbiAgICAgICAgY3VycmVudFkgKz0gMTA7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkVsZW1lbnRvIFBERiBubyBtYW5lamFkbyBleHBsw61jaXRhbWVudGU6XCIsIHRhZ05hbWUsIGVsZW1lbnQudGV4dENvbnRlbnQuc3Vic3RyaW5nKDAsMzApKTtcbiAgICAgICAgY3VycmVudFkgPSBhZGRUZXh0KGRvYywgZWxlbWVudC5pbm5lckhUTUwsIE1BUkdJTl9QVCwgY3VycmVudFksIGNvbnRlbnRXaWR0aCwge2lzSHRtbDogdHJ1ZX0pO1xuICAgICAgICBjdXJyZW50WSArPSA1O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7cHJvZ3JhbURhdGE/LmRlZ3JlZT8ucmVwbGFjZSgvXFxzKy9nLCAnXycpIHx8ICdwbGFuX2N1cnJpY3VsYXInfV8ke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCl9LnBkZmA7XG4gICAgZG9jLnNhdmUoZmlsZU5hbWUpO1xuXG4gICAgbm90aWZpY2F0aW9uLnN1Y2Nlc3Moe1xuICAgICAgbWVzc2FnZTogJ1BERiBFeHBvcnRhZG8nLFxuICAgICAgZGVzY3JpcHRpb246IGBFbCBwbGFuIGRlIGVzdHVkaW9zIHNlIGhhIGd1YXJkYWRvIGNvbW8gJHtmaWxlTmFtZX0uYCxcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbVJpZ2h0JyxcbiAgICAgIGljb246IDxDbG91ZERvd25sb2FkT3V0bGluZWQgc3R5bGU9e3sgY29sb3I6ICcjNTJjNDFhJyB9fSAvPixcbiAgICB9KTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGdlbmVyYXIgUERGOicsIGVycm9yKTtcbiAgICBub3RpZmljYXRpb24uZXJyb3Ioe1xuICAgICAgbWVzc2FnZTogJ0Vycm9yIGFsIEV4cG9ydGFyIFBERicsXG4gICAgICBkZXNjcmlwdGlvbjogZXJyb3IubWVzc2FnZSB8fCAnT2N1cnJpw7MgdW4gcHJvYmxlbWEgYWwgZ2VuZXJhciBlbCBhcmNoaXZvIFBERi4nLFxuICAgICAgcGxhY2VtZW50OiAnYm90dG9tUmlnaHQnLFxuICAgIH0pO1xuICB9XG59OyJdLCJuYW1lcyI6WyJqc1BERiIsImF1dG9UYWJsZSIsIm1hcmtlZCIsIkNsb3VkRG93bmxvYWRPdXRsaW5lZCIsIkRFRkFVTFRfRk9OVF9TSVpFX1BUIiwiVEFCTEVfRk9OVF9TSVpFX1BUIiwiSEVBREVSX0ZPTlRfU0laRV9QVCIsIkgxIiwiSDIiLCJIMyIsIkg0IiwiSDUiLCJINiIsIkxJTkVfSEVJR0hUX0ZBQ1RPUiIsIk1BUkdJTl9QVCIsImFkZFRleHQiLCJkb2MiLCJ0ZXh0IiwieCIsInkiLCJtYXhXaWR0aCIsIm9wdGlvbnMiLCJmb250U2l6ZSIsImZvbnRTdHlsZSIsImlzSHRtbCIsInNldEZvbnRTaXplIiwic2V0Rm9udCIsInVuZGVmaW5lZCIsInByb2Nlc3NlZFRleHQiLCJyZXBsYWNlIiwidGVtcERpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwiaW5uZXJUZXh0IiwibGluZXMiLCJzcGxpdFRleHRUb1NpemUiLCJ0ZXh0SGVpZ2h0IiwibGVuZ3RoIiwiaW50ZXJuYWwiLCJwYWdlU2l6ZSIsImhlaWdodCIsImFkZFBhZ2UiLCJsaW5lSGVpZ2h0RmFjdG9yIiwiZXhwb3J0VG9QZGYiLCJtYXJrZG93bkNvbnRlbnQiLCJwcm9ncmFtRGF0YSIsIm5vdGlmaWNhdGlvbiIsIndhcm4iLCJtZXNzYWdlIiwiZGVzY3JpcHRpb24iLCJodG1sU3RyaW5nIiwicGFyc2VyIiwiRE9NUGFyc2VyIiwiaHRtbERvYyIsInBhcnNlRnJvbVN0cmluZyIsImJvZHlFbGVtZW50cyIsIkFycmF5IiwiZnJvbSIsImJvZHkiLCJjaGlsZHJlbiIsIm9yaWVudGF0aW9uIiwidW5pdCIsImZvcm1hdCIsImN1cnJlbnRZIiwiY29udGVudFdpZHRoIiwid2lkdGgiLCJlbGVtZW50IiwidGFnTmFtZSIsInRvVXBwZXJDYXNlIiwiZm9yRWFjaCIsImxpIiwiaWR4IiwicHJlZml4Iiwic2V0RmlsbENvbG9yIiwidGVtcFkiLCJmaW5hbFkiLCJyZWN0IiwicGFyZW50RWxlbWVudCIsImhlYWRSb3dzIiwicXVlcnlTZWxlY3RvckFsbCIsInRyTm9kZSIsInJvdyIsInRoTm9kZSIsInB1c2giLCJ0cmltIiwiYm9keVJvd3MiLCJ0ZE5vZGUiLCJjZWxsSFRNTCIsImhlYWQiLCJzdGFydFkiLCJ0aGVtZSIsInN0eWxlcyIsImNlbGxQYWRkaW5nIiwib3ZlcmZsb3ciLCJoZWFkU3R5bGVzIiwiZmlsbENvbG9yIiwidGV4dENvbG9yIiwibWFyZ2luIiwibGVmdCIsInJpZ2h0IiwidGFibGVXaWR0aCIsImxhc3RBdXRvVGFibGUiLCJzZXREcmF3Q29sb3IiLCJsaW5lIiwiY29uc29sZSIsInN1YnN0cmluZyIsImZpbGVOYW1lIiwiZGVncmVlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2xpY2UiLCJzYXZlIiwic3VjY2VzcyIsInBsYWNlbWVudCIsImljb24iLCJzdHlsZSIsImNvbG9yIiwiZXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/exportPdf.js\n"));

/***/ })

});