"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./components/exportPdf.js":
/*!*********************************!*\
  !*** ./components/exportPdf.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportToPdf: () => (/* binding */ exportToPdf)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/.pnpm/react@19.1.0/node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf */ \"(pages-dir-browser)/./node_modules/.pnpm/jspdf@3.0.1/node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jspdf-autotable */ \"(pages-dir-browser)/./node_modules/.pnpm/jspdf-autotable@5.0.2_jspdf@3.0.1/node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! marked */ \"(pages-dir-browser)/./node_modules/.pnpm/marked@15.0.12/node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var _barrel_optimize_names_CloudDownloadOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=CloudDownloadOutlined!=!@ant-design/icons */ \"(pages-dir-browser)/__barrel_optimize__?names=CloudDownloadOutlined!=!./node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@ant-design/icons/es/index.js\");\n// File: components/exportPdf.js\n\n\n // Extiende jsPDF con el método autoTable\n\n\nconst DEFAULT_FONT_SIZE_PT = 10;\nconst TABLE_FONT_SIZE_PT = 6; // Tamaño de fuente muy pequeño para tablas\nconst HEADER_FONT_SIZE_PT = {\n    H1: 16,\n    H2: 14,\n    H3: 12,\n    H4: 10,\n    H5: 9,\n    H6: 8\n};\nconst LINE_HEIGHT_FACTOR = 1.2;\nconst MARGIN_PT = 30; // Margen uniforme\n// Helper para añadir texto con manejo de saltos de línea y de página\nfunction addText(doc, text, x, y, maxWidth) {\n    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};\n    const { fontSize = DEFAULT_FONT_SIZE_PT, fontStyle = 'normal', isHtml = false // Para manejar <br> como saltos de línea\n     } = options;\n    doc.setFontSize(fontSize);\n    doc.setFont(undefined, fontStyle); // Asume que la fuente por defecto es Helvetica o similar\n    let processedText = text;\n    if (isHtml) {\n        // Convertir <br> y <br /> a \\n\n        processedText = text.replace(/<br\\s*\\/?>/gi, '\\n');\n        // Simple strip de otros tags HTML para este helper, o usar un parser más robusto si se necesita\n        const tempDiv = document.createElement('div');\n        tempDiv.innerHTML = processedText;\n        processedText = tempDiv.textContent || tempDiv.innerText || \"\";\n    }\n    const lines = doc.splitTextToSize(processedText, maxWidth);\n    const textHeight = lines.length * fontSize * LINE_HEIGHT_FACTOR;\n    if (y + textHeight > doc.internal.pageSize.height - MARGIN_PT) {\n        doc.addPage();\n        y = MARGIN_PT;\n    }\n    doc.text(lines, x, y, {\n        lineHeightFactor: LINE_HEIGHT_FACTOR\n    });\n    return y + textHeight;\n}\nconst exportToPdf = async (markdownContent, programData, notification)=>{\n    if (!markdownContent) {\n        notification.warn({\n            message: 'Contenido Vacío',\n            description: 'No hay plan para exportar a PDF.'\n        });\n        return;\n    }\n    try {\n        var _programData_degree;\n        const htmlString = (0,marked__WEBPACK_IMPORTED_MODULE_3__.marked)(markdownContent);\n        const parser = new DOMParser();\n        const htmlDoc = parser.parseFromString(htmlString, 'text/html');\n        const bodyElements = Array.from(htmlDoc.body.children);\n        const doc = new jspdf__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n            orientation: 'p',\n            unit: 'pt',\n            format: 'a4'\n        });\n        let currentY = MARGIN_PT;\n        const contentWidth = doc.internal.pageSize.width - 2 * MARGIN_PT;\n        for (const element of bodyElements){\n            if (currentY > doc.internal.pageSize.height - MARGIN_PT - 20) {\n                doc.addPage();\n                currentY = MARGIN_PT;\n            }\n            const tagName = element.tagName.toUpperCase();\n            if (HEADER_FONT_SIZE_PT[tagName]) {\n                currentY = addText(doc, element.textContent, MARGIN_PT, currentY, contentWidth, {\n                    fontSize: HEADER_FONT_SIZE_PT[tagName],\n                    fontStyle: 'bold'\n                });\n                currentY += 5; // Espacio después del encabezado\n            } else if (tagName === 'P') {\n                currentY = addText(doc, element.innerHTML, MARGIN_PT, currentY, contentWidth, {\n                    isHtml: true\n                });\n                currentY += 5;\n            } else if (tagName === 'UL' || tagName === 'OL') {\n                Array.from(element.children).forEach((li, idx)=>{\n                    if (currentY > doc.internal.pageSize.height - MARGIN_PT - 10) {\n                        doc.addPage();\n                        currentY = MARGIN_PT;\n                    }\n                    const prefix = tagName === 'UL' ? '• ' : \"\".concat(idx + 1, \". \");\n                    // Usar innerHTML para que el helper addText lo procese (para <br>)\n                    currentY = addText(doc, prefix + li.innerHTML, MARGIN_PT + 10, currentY, contentWidth - 10, {\n                        isHtml: true\n                    });\n                });\n                currentY += 5;\n            } else if (tagName === 'BLOCKQUOTE') {\n                // Estilo simple para blockquote\n                doc.setFillColor(240, 240, 240);\n                const tempY = currentY;\n                const finalY = addText(doc, element.innerHTML, MARGIN_PT + 5, currentY, contentWidth - 10, {\n                    fontSize: DEFAULT_FONT_SIZE_PT - 1,\n                    fontStyle: 'italic',\n                    isHtml: true\n                });\n                doc.rect(MARGIN_PT, tempY - (DEFAULT_FONT_SIZE_PT - 1) / 2, 3, finalY - tempY + (DEFAULT_FONT_SIZE_PT - 1) / 2, 'F'); // Barra lateral\n                currentY = finalY + 5;\n            } else if (tagName === 'PRE' || tagName === 'CODE' && element.parentElement.tagName !== 'PRE') {\n                doc.setFont('courier', 'normal'); // Opcional: fuente monoespaciada para código\n                currentY = addText(doc, element.textContent, MARGIN_PT, currentY, contentWidth, {\n                    fontSize: DEFAULT_FONT_SIZE_PT - 2\n                });\n                doc.setFont(undefined, 'normal'); // Volver a la fuente por defecto\n                currentY += 5;\n            } else if (tagName === 'TABLE') {\n                const headRows = [];\n                element.querySelectorAll('thead tr').forEach((trNode)=>{\n                    const row = [];\n                    trNode.querySelectorAll('th').forEach((thNode)=>row.push(thNode.textContent.trim()));\n                    headRows.push(row);\n                });\n                const bodyRows = [];\n                element.querySelectorAll('tbody tr').forEach((trNode)=>{\n                    const row = [];\n                    trNode.querySelectorAll('td').forEach((tdNode)=>{\n                        // Para que autoTable interprete <br> como saltos de línea en celda\n                        const cellHTML = tdNode.innerHTML.replace(/<br\\s*\\/?>/gi, '\\n');\n                        const tempDiv = document.createElement('div');\n                        tempDiv.innerHTML = cellHTML; // Para decodificar entidades HTML si las hubiera\n                        row.push(tempDiv.textContent || tempDiv.innerText || \"\");\n                    });\n                    bodyRows.push(row);\n                });\n                if (currentY + 20 > doc.internal.pageSize.height - MARGIN_PT) {\n                    doc.addPage();\n                    currentY = MARGIN_PT;\n                }\n                doc.autoTable({\n                    head: headRows,\n                    body: bodyRows,\n                    startY: currentY,\n                    theme: 'grid',\n                    styles: {\n                        fontSize: TABLE_FONT_SIZE_PT,\n                        cellPadding: 1.5,\n                        overflow: 'linebreak'\n                    },\n                    headStyles: {\n                        fillColor: [\n                            41,\n                            128,\n                            185\n                        ],\n                        textColor: [\n                            255,\n                            255,\n                            255\n                        ],\n                        fontStyle: 'bold',\n                        fontSize: TABLE_FONT_SIZE_PT + 1\n                    },\n                    margin: {\n                        left: MARGIN_PT,\n                        right: MARGIN_PT\n                    },\n                    tableWidth: 'auto',\n                    // pageBreak: 'auto', // Ya es por defecto\n                    didDrawPage: (data)=>{\n                    // Puedes añadir encabezados/pies de página aquí si es necesario\n                    // currentY = MARGIN_PT; // No resetear aquí, autoTable lo maneja\n                    }\n                });\n                currentY = doc.lastAutoTable.finalY + 10; // Obtener la posición Y después de la tabla\n            } else if (tagName === 'HR') {\n                if (currentY + 10 > doc.internal.pageSize.height - MARGIN_PT) {\n                    doc.addPage();\n                    currentY = MARGIN_PT;\n                }\n                doc.setDrawColor(180, 180, 180);\n                doc.line(MARGIN_PT, currentY, doc.internal.pageSize.width - MARGIN_PT, currentY);\n                currentY += 10;\n            } else if (element.textContent.trim()) {\n                console.warn(\"Elemento PDF no manejado explícitamente:\", tagName, element.textContent.substring(0, 30));\n                currentY = addText(doc, element.innerHTML, MARGIN_PT, currentY, contentWidth, {\n                    isHtml: true\n                });\n                currentY += 5;\n            }\n        }\n        const fileName = \"\".concat((programData === null || programData === void 0 ? void 0 : (_programData_degree = programData.degree) === null || _programData_degree === void 0 ? void 0 : _programData_degree.replace(/\\s+/g, '_')) || 'plan_curricular', \"_\").concat(new Date().toISOString().slice(0, 10), \".pdf\");\n        doc.save(fileName);\n        notification.success({\n            message: 'PDF Exportado',\n            description: \"El plan de estudios se ha guardado como \".concat(fileName, \".\"),\n            placement: 'bottomRight',\n            icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_CloudDownloadOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__.CloudDownloadOutlined, {\n                style: {\n                    color: '#52c41a'\n                }\n            }, void 0, false, {\n                fileName: \"/home/jordan/Documents/Software Directrices/CURRICULAFORGE/components/exportPdf.js\",\n                lineNumber: 183,\n                columnNumber: 13\n            }, undefined)\n        });\n    } catch (error) {\n        console.error('Error al generar PDF:', error);\n        notification.error({\n            message: 'Error al Exportar PDF',\n            description: error.message || 'Ocurrió un problema al generar el archivo PDF.',\n            placement: 'bottomRight'\n        });\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvZXhwb3J0UGRmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxnQ0FBZ0M7O0FBQ047QUFDRCxDQUFDLHlDQUF5QztBQUNuQztBQUMwQjtBQUUxRCxNQUFNRyx1QkFBdUI7QUFDN0IsTUFBTUMscUJBQXFCLEdBQUcsMkNBQTJDO0FBQ3pFLE1BQU1DLHNCQUFzQjtJQUFFQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBR0MsSUFBSTtBQUFFO0FBQzNFLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxZQUFZLElBQUksa0JBQWtCO0FBRXhDLHFFQUFxRTtBQUNyRSxTQUFTQyxRQUFRQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLFFBQVE7UUFBRUMsVUFBQUEsaUVBQVUsQ0FBQztJQUNyRCxNQUFNLEVBQ0pDLFdBQVdsQixvQkFBb0IsRUFDL0JtQixZQUFZLFFBQVEsRUFDcEJDLFNBQVMsTUFBTSx5Q0FBeUM7SUFBMUMsRUFDZixHQUFHSDtJQUVKTCxJQUFJUyxXQUFXLENBQUNIO0lBQ2hCTixJQUFJVSxPQUFPLENBQUNDLFdBQVdKLFlBQVkseURBQXlEO0lBRTVGLElBQUlLLGdCQUFnQlg7SUFDcEIsSUFBSU8sUUFBUTtRQUNWLCtCQUErQjtRQUMvQkksZ0JBQWdCWCxLQUFLWSxPQUFPLENBQUMsZ0JBQWdCO1FBQzdDLGdHQUFnRztRQUNoRyxNQUFNQyxVQUFVQyxTQUFTQyxhQUFhLENBQUM7UUFDdkNGLFFBQVFHLFNBQVMsR0FBR0w7UUFDcEJBLGdCQUFnQkUsUUFBUUksV0FBVyxJQUFJSixRQUFRSyxTQUFTLElBQUk7SUFDOUQ7SUFFQSxNQUFNQyxRQUFRcEIsSUFBSXFCLGVBQWUsQ0FBQ1QsZUFBZVI7SUFDakQsTUFBTWtCLGFBQWFGLE1BQU1HLE1BQU0sR0FBR2pCLFdBQVdUO0lBRTdDLElBQUlNLElBQUltQixh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LFdBQVdtRDtnQkFDdkVBLFlBQVk7WUFDZCxPQUFPLElBQUlHLFFBQVFsQyxXQUFXLENBQUNvRCxJQUFJLElBQUk7Z0JBQ3JDdUIsUUFBUTVELElBQUksQ0FBQyw0Q0FBNENvQixTQUFTRCxRQUFRbEMsV0FBVyxDQUFDNEUsU0FBUyxDQUFDLEdBQUU7Z0JBQ2xHN0MsV0FBV2xELFFBQVFDLEtBQUtvRCxRQUFRbkMsU0FBUyxFQUFFbkIsV0FBV21ELFVBQVVDLGNBQWM7b0JBQUMxQyxRQUFRO2dCQUFJO2dCQUMzRnlDLFlBQVk7WUFDZDtRQUNGO1FBRUEsTUFBTThDLFdBQVcsR0FBcUUsT0FBbEVoRSxDQUFBQSx3QkFBQUEsbUNBQUFBLHNCQUFBQSxZQUFhaUUsTUFBTSxjQUFuQmpFLDBDQUFBQSxvQkFBcUJsQixPQUFPLENBQUMsUUFBUSxTQUFRLG1CQUFrQixLQUF5QyxPQUF0QyxJQUFJb0YsT0FBT0MsV0FBVyxHQUFHQyxLQUFLLENBQUMsR0FBRyxLQUFJO1FBQzVIbkcsSUFBSW9HLElBQUksQ0FBQ0w7UUFFVC9ELGFBQWFxRSxPQUFPLENBQUM7WUFDbkJuRSxTQUFTO1lBQ1RDLGFBQWEsMkNBQW9ELE9BQVQ0RCxVQUFTO1lBQ2pFTyxXQUFXO1lBQ1hDLG9CQUFNLDhEQUFDcEgsZ0hBQXFCQTtnQkFBQ3FILE9BQU87b0JBQUVDLE9BQU87Z0JBQVU7Ozs7OztRQUN6RDtJQUVGLEVBQUUsT0FBT0MsT0FBTztRQUNkYixRQUFRYSxLQUFLLENBQUMseUJBQXlCQTtRQUN2QzFFLGFBQWEwRSxLQUFLLENBQUM7WUFDakJ4RSxTQUFTO1lBQ1RDLGFBQWF1RSxNQUFNeEUsT0FBTyxJQUFJO1lBQzlCb0UsV0FBVztRQUNiO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvaG9tZS9qb3JkYW4vRG9jdW1lbnRzL1NvZnR3YXJlIERpcmVjdHJpY2VzL0NVUlJJQ1VMQUZPUkdFL2NvbXBvbmVudHMvZXhwb3J0UGRmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGU6IGNvbXBvbmVudHMvZXhwb3J0UGRmLmpzXG5pbXBvcnQganNQREYgZnJvbSAnanNwZGYnO1xuaW1wb3J0ICdqc3BkZi1hdXRvdGFibGUnOyAvLyBFeHRpZW5kZSBqc1BERiBjb24gZWwgbcOpdG9kbyBhdXRvVGFibGVcbmltcG9ydCB7IG1hcmtlZCB9IGZyb20gJ21hcmtlZCc7XG5pbXBvcnQgeyBDbG91ZERvd25sb2FkT3V0bGluZWQgfSBmcm9tICdAYW50LWRlc2lnbi9pY29ucyc7XG5cbmNvbnN0IERFRkFVTFRfRk9OVF9TSVpFX1BUID0gMTA7XG5jb25zdCBUQUJMRV9GT05UX1NJWkVfUFQgPSA2OyAvLyBUYW1hw7FvIGRlIGZ1ZW50ZSBtdXkgcGVxdWXDsW8gcGFyYSB0YWJsYXNcbmNvbnN0IEhFQURFUl9GT05UX1NJWkVfUFQgPSB7IEgxOiAxNiwgSDI6IDE0LCBIMzogMTIsIEg0OiAxMCwgSDU6IDksIEg2OiA4IH07XG5jb25zdCBMSU5FX0hFSUdIVF9GQUNUT1IgPSAxLjI7XG5jb25zdCBNQVJHSU5fUFQgPSAzMDsgLy8gTWFyZ2VuIHVuaWZvcm1lXG5cbi8vIEhlbHBlciBwYXJhIGHDsWFkaXIgdGV4dG8gY29uIG1hbmVqbyBkZSBzYWx0b3MgZGUgbMOtbmVhIHkgZGUgcMOhZ2luYVxuZnVuY3Rpb24gYWRkVGV4dChkb2MsIHRleHQsIHgsIHksIG1heFdpZHRoLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGZvbnRTaXplID0gREVGQVVMVF9GT05UX1NJWkVfUFQsXG4gICAgZm9udFN0eWxlID0gJ25vcm1hbCcsXG4gICAgaXNIdG1sID0gZmFsc2UgLy8gUGFyYSBtYW5lamFyIDxicj4gY29tbyBzYWx0b3MgZGUgbMOtbmVhXG4gIH0gPSBvcHRpb25zO1xuXG4gIGRvYy5zZXRGb250U2l6ZShmb250U2l6ZSk7XG4gIGRvYy5zZXRGb250KHVuZGVmaW5lZCwgZm9udFN0eWxlKTsgLy8gQXN1bWUgcXVlIGxhIGZ1ZW50ZSBwb3IgZGVmZWN0byBlcyBIZWx2ZXRpY2EgbyBzaW1pbGFyXG5cbiAgbGV0IHByb2Nlc3NlZFRleHQgPSB0ZXh0O1xuICBpZiAoaXNIdG1sKSB7XG4gICAgLy8gQ29udmVydGlyIDxicj4geSA8YnIgLz4gYSBcXG5cbiAgICBwcm9jZXNzZWRUZXh0ID0gdGV4dC5yZXBsYWNlKC88YnJcXHMqXFwvPz4vZ2ksICdcXG4nKTtcbiAgICAvLyBTaW1wbGUgc3RyaXAgZGUgb3Ryb3MgdGFncyBIVE1MIHBhcmEgZXN0ZSBoZWxwZXIsIG8gdXNhciB1biBwYXJzZXIgbcOhcyByb2J1c3RvIHNpIHNlIG5lY2VzaXRhXG4gICAgY29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gcHJvY2Vzc2VkVGV4dDtcbiAgICBwcm9jZXNzZWRUZXh0ID0gdGVtcERpdi50ZXh0Q29udGVudCB8fCB0ZW1wRGl2LmlubmVyVGV4dCB8fCBcIlwiO1xuICB9XG5cbiAgY29uc3QgbGluZXMgPSBkb2Muc3BsaXRUZXh0VG9TaXplKHByb2Nlc3NlZFRleHQsIG1heFdpZHRoKTtcbiAgY29uc3QgdGV4dEhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGZvbnRTaXplICogTElORV9IRUlHSFRfRkFDVE9SO1xuXG4gIGlmICh5ICsgdGV4dEhlaWdodCA+IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQgLSBNQVJHSU5fUFQpIHtcbiAgICBkb2MuYWRkUGFnZSgpO1xuICAgIHkgPSBNQVJHSU5fUFQ7XG4gIH1cbiAgZG9jLnRleHQobGluZXMsIHgsIHksIHsgbGluZUhlaWdodEZhY3RvcjogTElORV9IRUlHSFRfRkFDVE9SIH0pO1xuICByZXR1cm4geSArIHRleHRIZWlnaHQ7XG59XG5cblxuZXhwb3J0IGNvbnN0IGV4cG9ydFRvUGRmID0gYXN5bmMgKG1hcmtkb3duQ29udGVudCwgcHJvZ3JhbURhdGEsIG5vdGlmaWNhdGlvbikgPT4ge1xuICBpZiAoIW1hcmtkb3duQ29udGVudCkge1xuICAgIG5vdGlmaWNhdGlvbi53YXJuKHtcbiAgICAgIG1lc3NhZ2U6ICdDb250ZW5pZG8gVmFjw61vJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnTm8gaGF5IHBsYW4gcGFyYSBleHBvcnRhciBhIFBERi4nLFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgaHRtbFN0cmluZyA9IG1hcmtlZChtYXJrZG93bkNvbnRlbnQpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICBjb25zdCBodG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sU3RyaW5nLCAndGV4dC9odG1sJyk7XG4gICAgY29uc3QgYm9keUVsZW1lbnRzID0gQXJyYXkuZnJvbShodG1sRG9jLmJvZHkuY2hpbGRyZW4pO1xuXG4gICAgY29uc3QgZG9jID0gbmV3IGpzUERGKHtcbiAgICAgIG9yaWVudGF0aW9uOiAncCcsIC8vICdwJyBwYXJhIHBvcnRyYWl0LiBDYW1iaWFyIGEgJ2wnIChsYW5kc2NhcGUpIHNpIGxhcyB0YWJsYXMgc29uIG11eSBhbmNoYXNcbiAgICAgIHVuaXQ6ICdwdCcsXG4gICAgICBmb3JtYXQ6ICdhNCcsXG4gICAgfSk7XG5cbiAgICBsZXQgY3VycmVudFkgPSBNQVJHSU5fUFQ7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gZG9jLmludGVybmFsLnBhZ2VTaXplLndpZHRoIC0gMiAqIE1BUkdJTl9QVDtcblxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBib2R5RWxlbWVudHMpIHtcbiAgICAgIGlmIChjdXJyZW50WSA+IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQgLSBNQVJHSU5fUFQgLSAyMCkgeyAvLyBNYXJnZW4gaW5mZXJpb3IgYW50ZXMgZGUgYcOxYWRpciBudWV2byBlbGVtZW50b1xuICAgICAgICAgZG9jLmFkZFBhZ2UoKTtcbiAgICAgICAgIGN1cnJlbnRZID0gTUFSR0lOX1BUO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgIGlmIChIRUFERVJfRk9OVF9TSVpFX1BUW3RhZ05hbWVdKSB7XG4gICAgICAgIGN1cnJlbnRZID0gYWRkVGV4dChkb2MsIGVsZW1lbnQudGV4dENvbnRlbnQsIE1BUkdJTl9QVCwgY3VycmVudFksIGNvbnRlbnRXaWR0aCwge1xuICAgICAgICAgIGZvbnRTaXplOiBIRUFERVJfRk9OVF9TSVpFX1BUW3RhZ05hbWVdLFxuICAgICAgICAgIGZvbnRTdHlsZTogJ2JvbGQnLFxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudFkgKz0gNTsgLy8gRXNwYWNpbyBkZXNwdcOpcyBkZWwgZW5jYWJlemFkb1xuICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnUCcpIHtcbiAgICAgICAgY3VycmVudFkgPSBhZGRUZXh0KGRvYywgZWxlbWVudC5pbm5lckhUTUwsIE1BUkdJTl9QVCwgY3VycmVudFksIGNvbnRlbnRXaWR0aCwgeyBpc0h0bWw6IHRydWUgfSk7XG4gICAgICAgIGN1cnJlbnRZICs9IDU7XG4gICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdVTCcgfHwgdGFnTmFtZSA9PT0gJ09MJykge1xuICAgICAgICBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGRyZW4pLmZvckVhY2goKGxpLCBpZHgpID0+IHtcbiAgICAgICAgICBpZiAoY3VycmVudFkgPiBkb2MuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0IC0gTUFSR0lOX1BUIC0gMTApIHtcbiAgICAgICAgICAgIGRvYy5hZGRQYWdlKCk7IGN1cnJlbnRZID0gTUFSR0lOX1BUO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwcmVmaXggPSB0YWdOYW1lID09PSAnVUwnID8gJ+KAoiAnIDogYCR7aWR4ICsgMX0uIGA7XG4gICAgICAgICAgLy8gVXNhciBpbm5lckhUTUwgcGFyYSBxdWUgZWwgaGVscGVyIGFkZFRleHQgbG8gcHJvY2VzZSAocGFyYSA8YnI+KVxuICAgICAgICAgIGN1cnJlbnRZID0gYWRkVGV4dChkb2MsIHByZWZpeCArIGxpLmlubmVySFRNTCwgTUFSR0lOX1BUICsgMTAsIGN1cnJlbnRZLCBjb250ZW50V2lkdGggLSAxMCwgeyBpc0h0bWw6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50WSArPSA1O1xuICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnQkxPQ0tRVU9URScpIHtcbiAgICAgICAgLy8gRXN0aWxvIHNpbXBsZSBwYXJhIGJsb2NrcXVvdGVcbiAgICAgICAgZG9jLnNldEZpbGxDb2xvcigyNDAsIDI0MCwgMjQwKTtcbiAgICAgICAgY29uc3QgdGVtcFkgPSBjdXJyZW50WTtcbiAgICAgICAgY29uc3QgZmluYWxZID0gYWRkVGV4dChkb2MsIGVsZW1lbnQuaW5uZXJIVE1MLCBNQVJHSU5fUFQgKyA1LCBjdXJyZW50WSwgY29udGVudFdpZHRoIC0gMTAsIHsgZm9udFNpemU6IERFRkFVTFRfRk9OVF9TSVpFX1BUIC0xLCBmb250U3R5bGU6ICdpdGFsaWMnLCBpc0h0bWw6IHRydWUgfSk7XG4gICAgICAgIGRvYy5yZWN0KE1BUkdJTl9QVCwgdGVtcFkgLSAoREVGQVVMVF9GT05UX1NJWkVfUFQgLTEpLzIgLCAzLCBmaW5hbFkgLSB0ZW1wWSArIChERUZBVUxUX0ZPTlRfU0laRV9QVCAtMSkvMiwgJ0YnKTsgLy8gQmFycmEgbGF0ZXJhbFxuICAgICAgICBjdXJyZW50WSA9IGZpbmFsWSArIDU7XG4gICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdQUkUnIHx8ICh0YWdOYW1lID09PSAnQ09ERScgJiYgZWxlbWVudC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgIT09ICdQUkUnKSkge1xuICAgICAgICBkb2Muc2V0Rm9udCgnY291cmllcicsICdub3JtYWwnKTsgLy8gT3BjaW9uYWw6IGZ1ZW50ZSBtb25vZXNwYWNpYWRhIHBhcmEgY8OzZGlnb1xuICAgICAgICBjdXJyZW50WSA9IGFkZFRleHQoZG9jLCBlbGVtZW50LnRleHRDb250ZW50LCBNQVJHSU5fUFQsIGN1cnJlbnRZLCBjb250ZW50V2lkdGgsIHsgZm9udFNpemU6IERFRkFVTFRfRk9OVF9TSVpFX1BUIC0gMiB9KTtcbiAgICAgICAgZG9jLnNldEZvbnQodW5kZWZpbmVkLCAnbm9ybWFsJyk7IC8vIFZvbHZlciBhIGxhIGZ1ZW50ZSBwb3IgZGVmZWN0b1xuICAgICAgICBjdXJyZW50WSArPSA1O1xuICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnVEFCTEUnKSB7XG4gICAgICAgIGNvbnN0IGhlYWRSb3dzID0gW107XG4gICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgndGhlYWQgdHInKS5mb3JFYWNoKHRyTm9kZSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgICAgIHRyTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0aCcpLmZvckVhY2godGhOb2RlID0+IHJvdy5wdXNoKHRoTm9kZS50ZXh0Q29udGVudC50cmltKCkpKTtcbiAgICAgICAgICAgIGhlYWRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYm9keVJvd3MgPSBbXTtcbiAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCd0Ym9keSB0cicpLmZvckVhY2godHJOb2RlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICAgICAgdHJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RkJykuZm9yRWFjaCh0ZE5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAvLyBQYXJhIHF1ZSBhdXRvVGFibGUgaW50ZXJwcmV0ZSA8YnI+IGNvbW8gc2FsdG9zIGRlIGzDrW5lYSBlbiBjZWxkYVxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxIVE1MID0gdGROb2RlLmlubmVySFRNTC5yZXBsYWNlKC88YnJcXHMqXFwvPz4vZ2ksICdcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBjZWxsSFRNTDsgLy8gUGFyYSBkZWNvZGlmaWNhciBlbnRpZGFkZXMgSFRNTCBzaSBsYXMgaHViaWVyYVxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKHRlbXBEaXYudGV4dENvbnRlbnQgfHwgdGVtcERpdi5pbm5lclRleHQgfHwgXCJcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJvZHlSb3dzLnB1c2gocm93KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY3VycmVudFkgKyAyMCA+IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQgLSBNQVJHSU5fUFQpIHtcbiAgICAgICAgICAgIGRvYy5hZGRQYWdlKCk7XG4gICAgICAgICAgICBjdXJyZW50WSA9IE1BUkdJTl9QVDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvYy5hdXRvVGFibGUoe1xuICAgICAgICAgIGhlYWQ6IGhlYWRSb3dzLFxuICAgICAgICAgIGJvZHk6IGJvZHlSb3dzLFxuICAgICAgICAgIHN0YXJ0WTogY3VycmVudFksXG4gICAgICAgICAgdGhlbWU6ICdncmlkJywgLy8gJ3N0cmlwZWQnLCAnZ3JpZCcsICdwbGFpbidcbiAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiBUQUJMRV9GT05UX1NJWkVfUFQsXG4gICAgICAgICAgICBjZWxsUGFkZGluZzogMS41LCAvLyBSZWR1Y2lyIHBhZGRpbmdcbiAgICAgICAgICAgIG92ZXJmbG93OiAnbGluZWJyZWFrJywgLy8gJ2VsbGlwc2l6ZScsICd2aXNpYmxlJywgJ2hpZGRlbicsICdsaW5lYnJlYWsnXG4gICAgICAgICAgICAvLyBsaW5lV2lkdGg6IDAuMSwgLy8gTMOtbmVhcyBtw6FzIGZpbmFzIChvcGNpb25hbClcbiAgICAgICAgICAgIC8vIGxpbmVDb2xvcjogWzE1MCwgMTUwLCAxNTBdLCAvLyBDb2xvciBkZSBsw61uZWEgbcOhcyBjbGFybyAob3BjaW9uYWwpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWFkU3R5bGVzOiB7XG4gICAgICAgICAgICBmaWxsQ29sb3I6IFs0MSwgMTI4LCAxODVdLCAvLyBVbiBhenVsIHBhcmEgZWwgZW5jYWJlemFkbyBkZSBsYSB0YWJsYVxuICAgICAgICAgICAgdGV4dENvbG9yOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICAgICAgICBmb250U3R5bGU6ICdib2xkJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiBUQUJMRV9GT05UX1NJWkVfUFQgKyAxLCAvLyBVbiBwb2NvIG3DoXMgZ3JhbmRlIHBhcmEgZW5jYWJlemFkb3MgZGUgdGFibGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmdpbjogeyBsZWZ0OiBNQVJHSU5fUFQsIHJpZ2h0OiBNQVJHSU5fUFQgfSxcbiAgICAgICAgICB0YWJsZVdpZHRoOiAnYXV0bycsIC8vICdhdXRvJyAoaW50ZW50YSBlbmNhamFyKSwgJ3dyYXAnICh1c2EgdG9kbyBlbCBhbmNobyksIG8gdW4gbsO6bWVyb1xuICAgICAgICAgIC8vIHBhZ2VCcmVhazogJ2F1dG8nLCAvLyBZYSBlcyBwb3IgZGVmZWN0b1xuICAgICAgICAgIGRpZERyYXdQYWdlOiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gUHVlZGVzIGHDsWFkaXIgZW5jYWJlemFkb3MvcGllcyBkZSBww6FnaW5hIGFxdcOtIHNpIGVzIG5lY2VzYXJpb1xuICAgICAgICAgICAgLy8gY3VycmVudFkgPSBNQVJHSU5fUFQ7IC8vIE5vIHJlc2V0ZWFyIGFxdcOtLCBhdXRvVGFibGUgbG8gbWFuZWphXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnRZID0gZG9jLmxhc3RBdXRvVGFibGUuZmluYWxZICsgMTA7IC8vIE9idGVuZXIgbGEgcG9zaWNpw7NuIFkgZGVzcHXDqXMgZGUgbGEgdGFibGFcbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ0hSJykge1xuICAgICAgICBpZiAoY3VycmVudFkgKyAxMCA+IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQgLSBNQVJHSU5fUFQpIHtcbiAgICAgICAgICAgIGRvYy5hZGRQYWdlKCk7IGN1cnJlbnRZID0gTUFSR0lOX1BUO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5zZXREcmF3Q29sb3IoMTgwLCAxODAsIDE4MCk7XG4gICAgICAgIGRvYy5saW5lKE1BUkdJTl9QVCwgY3VycmVudFksIGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS53aWR0aCAtIE1BUkdJTl9QVCwgY3VycmVudFkpO1xuICAgICAgICBjdXJyZW50WSArPSAxMDtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC50ZXh0Q29udGVudC50cmltKCkpIHsgLy8gRWxlbWVudG8gZGVzY29ub2NpZG8gcGVybyBjb24gdGV4dG9cbiAgICAgICAgY29uc29sZS53YXJuKFwiRWxlbWVudG8gUERGIG5vIG1hbmVqYWRvIGV4cGzDrWNpdGFtZW50ZTpcIiwgdGFnTmFtZSwgZWxlbWVudC50ZXh0Q29udGVudC5zdWJzdHJpbmcoMCwzMCkpO1xuICAgICAgICBjdXJyZW50WSA9IGFkZFRleHQoZG9jLCBlbGVtZW50LmlubmVySFRNTCwgTUFSR0lOX1BULCBjdXJyZW50WSwgY29udGVudFdpZHRoLCB7aXNIdG1sOiB0cnVlfSk7XG4gICAgICAgIGN1cnJlbnRZICs9IDU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZU5hbWUgPSBgJHtwcm9ncmFtRGF0YT8uZGVncmVlPy5yZXBsYWNlKC9cXHMrL2csICdfJykgfHwgJ3BsYW5fY3VycmljdWxhcid9XyR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDEwKX0ucGRmYDtcbiAgICBkb2Muc2F2ZShmaWxlTmFtZSk7XG5cbiAgICBub3RpZmljYXRpb24uc3VjY2Vzcyh7XG4gICAgICBtZXNzYWdlOiAnUERGIEV4cG9ydGFkbycsXG4gICAgICBkZXNjcmlwdGlvbjogYEVsIHBsYW4gZGUgZXN0dWRpb3Mgc2UgaGEgZ3VhcmRhZG8gY29tbyAke2ZpbGVOYW1lfS5gLFxuICAgICAgcGxhY2VtZW50OiAnYm90dG9tUmlnaHQnLFxuICAgICAgaWNvbjogPENsb3VkRG93bmxvYWRPdXRsaW5lZCBzdHlsZT17eyBjb2xvcjogJyM1MmM0MWEnIH19IC8+LFxuICAgIH0pO1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgZ2VuZXJhciBQREY6JywgZXJyb3IpO1xuICAgIG5vdGlmaWNhdGlvbi5lcnJvcih7XG4gICAgICBtZXNzYWdlOiAnRXJyb3IgYWwgRXhwb3J0YXIgUERGJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBlcnJvci5tZXNzYWdlIHx8ICdPY3VycmnDsyB1biBwcm9ibGVtYSBhbCBnZW5lcmFyIGVsIGFyY2hpdm8gUERGLicsXG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b21SaWdodCcsXG4gICAgfSk7XG4gIH1cbn07Il0sIm5hbWVzIjpbImpzUERGIiwibWFya2VkIiwiQ2xvdWREb3dubG9hZE91dGxpbmVkIiwiREVGQVVMVF9GT05UX1NJWkVfUFQiLCJUQUJMRV9GT05UX1NJWkVfUFQiLCJIRUFERVJfRk9OVF9TSVpFX1BUIiwiSDEiLCJIMiIsIkgzIiwiSDQiLCJINSIsIkg2IiwiTElORV9IRUlHSFRfRkFDVE9SIiwiTUFSR0lOX1BUIiwiYWRkVGV4dCIsImRvYyIsInRleHQiLCJ4IiwieSIsIm1heFdpZHRoIiwib3B0aW9ucyIsImZvbnRTaXplIiwiZm9udFN0eWxlIiwiaXNIdG1sIiwic2V0Rm9udFNpemUiLCJzZXRGb250IiwidW5kZWZpbmVkIiwicHJvY2Vzc2VkVGV4dCIsInJlcGxhY2UiLCJ0ZW1wRGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwidGV4dENvbnRlbnQiLCJpbm5lclRleHQiLCJsaW5lcyIsInNwbGl0VGV4dFRvU2l6ZSIsInRleHRIZWlnaHQiLCJsZW5ndGgiLCJpbnRlcm5hbCIsInBhZ2VTaXplIiwiaGVpZ2h0IiwiYWRkUGFnZSIsImxpbmVIZWlnaHRGYWN0b3IiLCJleHBvcnRUb1BkZiIsIm1hcmtkb3duQ29udGVudCIsInByb2dyYW1EYXRhIiwibm90aWZpY2F0aW9uIiwid2FybiIsIm1lc3NhZ2UiLCJkZXNjcmlwdGlvbiIsImh0bWxTdHJpbmciLCJwYXJzZXIiLCJET01QYXJzZXIiLCJodG1sRG9jIiwicGFyc2VGcm9tU3RyaW5nIiwiYm9keUVsZW1lbnRzIiwiQXJyYXkiLCJmcm9tIiwiYm9keSIsImNoaWxkcmVuIiwib3JpZW50YXRpb24iLCJ1bml0IiwiZm9ybWF0IiwiY3VycmVudFkiLCJjb250ZW50V2lkdGgiLCJ3aWR0aCIsImVsZW1lbnQiLCJ0YWdOYW1lIiwidG9VcHBlckNhc2UiLCJmb3JFYWNoIiwibGkiLCJpZHgiLCJwcmVmaXgiLCJzZXRGaWxsQ29sb3IiLCJ0ZW1wWSIsImZpbmFsWSIsInJlY3QiLCJwYXJlbnRFbGVtZW50IiwiaGVhZFJvd3MiLCJxdWVyeVNlbGVjdG9yQWxsIiwidHJOb2RlIiwicm93IiwidGhOb2RlIiwicHVzaCIsInRyaW0iLCJib2R5Um93cyIsInRkTm9kZSIsImNlbGxIVE1MIiwiYXV0b1RhYmxlIiwiaGVhZCIsInN0YXJ0WSIsInRoZW1lIiwic3R5bGVzIiwiY2VsbFBhZGRpbmciLCJvdmVyZmxvdyIsImhlYWRTdHlsZXMiLCJmaWxsQ29sb3IiLCJ0ZXh0Q29sb3IiLCJtYXJnaW4iLCJsZWZ0IiwicmlnaHQiLCJ0YWJsZVdpZHRoIiwiZGlkRHJhd1BhZ2UiLCJkYXRhIiwibGFzdEF1dG9UYWJsZSIsInNldERyYXdDb2xvciIsImxpbmUiLCJjb25zb2xlIiwic3Vic3RyaW5nIiwiZmlsZU5hbWUiLCJkZWdyZWUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzbGljZSIsInNhdmUiLCJzdWNjZXNzIiwicGxhY2VtZW50IiwiaWNvbiIsInN0eWxlIiwiY29sb3IiLCJlcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/exportPdf.js\n"));

/***/ })

});